---
pdf-engine: xelatex
geometry: 
    - a4paper
    - bottom=1.5cm
    - includefoot
mainfont: "Times New Roman"
monofont: "DejaVu Sans Mono"
mathfont: "TeX Gyre Termes Math"
titlepage: true
titlepage-rule-height: 0
titlepage-color: "F4F460"  # Background color (Orange)
output: pdf_document
lang: "ru"
header-includes:
  - \usepackage{multirow}
  - \usepackage{placeins} 
  - \usepackage{array}  # Enables column width control
  - \renewcommand{\arraystretch}{1.5}  # Increases vertical cell spacing # This package helps keep tables in place
  - \usepackage{pdflscape}
  - \usepackage{longtable,booktabs}
  - \usepackage{tabularx}
---

\begin{titlepage}
\centering
{\Large \textbf{Федеральное государственное автономное образовательное учреждение высшего образования}}\\[0.5cm]
{\Large \textbf{Университет ИТМО}}\\[3cm]
{\Large Дисциплина:   Программирование встраиваемых систем}\\[0.5cm]
{\Huge Курсовая работа}\\

\vfill

\begin{flushright}
\textbf{Работу выполнили,\\
студенты группы P4219:}\\
Ануфриев Илья Владимирович,\\
Василев Васил Николаев,\\
Кадырин Вадим Юрьевич,\\
Суховей Ярослав Юрьевич\\[1cm]
\textbf{Преподаватель:}\\
к.т.н., доцент ПИКТ\\
Ключев Аркадий Олегович \\[3cm]
\end{flushright}

\vfill
2025 г.\\
Санкт-Петербург
\end{titlepage}

\newpage

\tableofcontents

\newpage

# Введение

Современные встраиваемые и распределённые системы требуют не только высокой производительности, но и прозрачной модели взаимодействия программных и аппаратных компонентов. Традиционные подходы либо фиксируют архитектуру (жёстко разделяя hardware и software), либо не дают удобного формального описания сети взаимодействующих вычислительных узлов. В результате усложняется проектирование, тестирование и повторное использование решений.

Проект Solace предлагает экспериментальный язык программирования и семейство виртуальных машин, ориентированных на моделирование вычислений в терминах узлов и каналов сети Кана. Язык позволяет единообразно описывать как аппаратно‑ориентированные (hardware) узлы, реализуемые в виде комбинационных схем, так и программные (software) узлы на основе стековой машины. Сетевая виртуальная машина восстанавливает из единого бинарного пакета топологию сети и запускает соответствующие узловые ВМ, связывая их через асинхронные FIFO‑каналы.

Цель данной работы — описать архитектуру и реализацию языка Solace, компилятора и виртуальных машин, а также способы их тестирования. В отчёте приводится обзор формата выходных файлов, принципов построения сети Кана, моделей вычислений для аппаратных и программных узлов и методик верификации корректности работы подсистем.

\newpage

# ТЗ

Основной объект разработки — экосистема языка Solace, включающая:

- язык описания узлов и глобальной сети (`*.solace`);
- компилятор (`compiler`), преобразующий исходный код в единый бинарный пакет `*.solpkg`;
- набор виртуальных машин:
  - симулятор аппаратных узлов (`vm/sim`);
  - стековая ВМ Harv для программных узлов (`vm/harv`);
  - сетевая ВМ (`vm/network`), строящая сеть Кана и запускающая узловые ВМ.

Ключевые функциональные требования к системе:

1. **Язык и модель вычислений**
   - Поддержка двух типов узлов: `hardware` (комбинационная логика) и `software` (стековая машина).
   - Наличие трёх типов портов: `in`, `out`, `self`.
   - Разделение кода узла на секции `init {}` и `run {}`, где `init` выполняется однократно при запуске, а `run` — в цикле.
   - Описание глобальной сети в секции `network { ... }` с явным перечислением соединений вида `A.out -> B.in;`.

2. **Компилятор**
   - Синтаксический анализ исходного файла `.solace` с использованием ANTLR‑грамматики `Solace.g4`.
   - Семантический анализ:
     - сбор списка узлов, их типов и портов;
     - проверка корректности соединений и отсутствия ссылок на неизвестные узлы/порты;
     - проверка отсутствия дублирующихся портов и соединений;
     - диагностика неиспользованных выходных и self‑портов в сети и коде.
   - Генерация байткода:
     - для аппаратных узлов — в формате, исполняемом симулятором комбинационной логики;
     - для программных узлов — в формате байткода стековой машины Harv.
   - Формирование единого пакетного файла `*.solpkg` (формат `SOLP`), содержащего:
     - заголовок с метаданными о пакете;
     - таблицу строк (имена узлов и портов);
     - поток инструкций `NODE_DEF`/`CONNECT`, описывающий сеть;
     - встроенные контейнеры байткода узлов формата `solbc` (`SOLB`).

3. **Сетевая виртуальная машина (network VM)**
   - Загрузка файла формата `SOLP` с диска, в том числе с поиском относительно текущего каталога.
   - Разбор таблицы строк и потока инструкций:
     - восстановление списка узлов с их типами и сигнатурами портов;
     - восстановление списка соединений между портами.
   - Валидация структуры:
     - проверка magic‑чисел, версий и размеров секций;
     - согласованность типов узлов в метаданных и контейнерах `solbc`;
     - проверка корректности подключений всех портов.
   - Построение сети Кана:
     - создание отдельных FIFO‑каналов для всех соединений;
     - создание self‑каналов для self‑портов и их «разветвление» на вход и выход.
   - Запуск узловых ВМ:
     - поддержка различных фабрик узловых ВМ (stub, симуляторная, Harv, смешанная);
     - управление временем работы сети, корректное завершение и сбор статистики.
   - Поддержка режимов наблюдения:
     - текстовый sniff‑режим с выводом всех сообщений;
     - логирование трафика в CSV‑формате с ограничением по числу записей.

4. **Симулятор аппаратных узлов (`vm/sim`)**
   - Реализация модели комбинационной логики:
     - набор базовых элементов (арифметические, логические, регистры, мультиплексоры, FIFO‑очереди);
     - представление схемы в виде графа `NetlistGraph`.
   - Поддержка self‑очередей для хранения состояния между тактами.
   - Определение статусов выполнения блока (`SUCCESS`, `BLOCKED`, `ERROR`) в зависимости от доступности данных во входных очередях и корректности вычислений.

5. **Стековая ВМ Harv (`vm/harv`)**
   - Реализация стековой архитектуры с поддержкой:
     - целых чисел и строк;
     - FIFO‑очередей как объектов с блокирующим поведением;
     - идентификаторов и таблицы переменных;
     - меток и условных/безусловных переходов.
   - Набор инструкций для арифметики, логики, работы со стеком, управления выполнением, определения переменных, входа‑выхода и получения размера FIFO.
   - Разделение байткода на инициализационную и основную фазу исполнения.

6. **Нефункциональные требования**
   - Реализация всех компонентов на языке Kotlin.
   - Модульная архитектура и чёткие интерфейсы между компилятором и ВМ.
   - Документированный формат выходных файлов (`FILE_FORMATS.md`).
   - Наличие автоматических тестов для ключевых подсистем.

Дополнительно ТЗ подразумевает, что язык и инфраструктура Solace должны быть пригодны как для учебных, так и для исследовательских задач: разработчик должен иметь возможность быстро описывать новые конфигурации сети, комбинировать аппаратные и программные узлы, анализировать структуру получившейся сети и воспроизводить эксперименты.

## Типовой сценарий использования системы

С точки зрения конечного пользователя (разработчика), работа с системой Solace выглядит следующим образом:

1. На языке Solace описывается набор узлов (`hardware` и/или `software`) и глобальная сеть `network`, задающая соединения между ними.
2. Исходный файл `program.solace` передаётся компилятору:
   - компилятор выполняет синтаксический и семантический анализ;
   - по результатам анализа формируется пакет `program.solpkg` с описанием сети и встроенным байткодом всех узлов.
3. Полученный пакет загружается сетевой ВМ:
   - ВМ читает заголовок и мета‑секцию, восстанавливая список узлов и соединений;
   - создаются FIFO‑каналы и self‑каналы для всех портов.
4. Пользователь выбирает режим исполнения:
   - заглушечный (stub) — для быстрой проверки топологии и корректности проводки портов;
   - симуляторный (`sim`) — для исполнения только аппаратных узлов;
   - программный (`harv`) — для программных сетей;
   - смешанный (`mixed`) — для одновременного запуска аппаратных и программных узлов.
5. Сеть запускается на ограниченное время или до завершения всех узлов; при необходимости включается sniff‑режим или сбор CSV‑логов трафика.

Такой сценарий обеспечивает единый жизненный цикл: от высокоуровневого описания сети до её исполнения и анализа поведения.

## Ограничения и допущения

В ТЗ и спецификациях формата выходных файлов зафиксированы следующие важные ограничения:

- Таблица строк в пакете `SOLP`:
  - максимальное число строк — 65535;
  - максимальная длина одной строки в UTF‑8 — 65535 байт.
- Порты узлов:
  - количество портов каждого типа (`in`, `out`, `self`) ограничено значением `u8` (не более 255);
  - имена узлов в пакете уникальны.
- Формат контейнера байткода `SOLB`:
  - чётко фиксирована структура заголовка (magic `"SOLB"`, версии, тип узла, размеры секций `init` и `run`);
  - секции `init` и `run` могут иметь нулевой размер, если соответствующий блок в исходнике отсутствует.
- Типы данных:
  - аппаратные узлы оперируют целыми числами, соответствующими целочисленному типу в симуляторе;
  - программные узлы дополнительно поддерживают строки и абстракции FIFO‑очередей.

Эти ограничения позволяют упростить реализацию загрузчиков, симулятора и стековой машины, а также гарантируют совместимость между версиями компилятора и ВМ.

\newpage

# Архитектура

Архитектура Solace опирается на трёхслойную модель:

1. **Фронтенд (язык и компилятор)**
   - Исходный код `*.solace` описывает:
     - узлы (`node`) с типом `hardware` или `software`, портами `in`/`out`/`self` и секциями `init`/`run`;
     - глобальную сеть `network`, задающую соединения между портами.
   - Грамматика ANTLR4 (`Solace.g4`) определяет синтаксис языка и используется для построения AST.
   - Компилятор, работая поверх AST, выполняет:
     - анализ сети и проверку корректности топологии;
     - генерацию байткода для аппаратных и программных узлов;
     - упаковку результата в пакет `SOLP` с встроенными контейнерами `SOLB`.

2. **Узловые виртуальные машины**
   - **Симулятор аппаратных узлов (`vm/sim`)**:
     - представляет вычисления в виде графа `NetlistGraph`, где вершины — примитивные элементы (Adder, Multiplier, LogicAnd и др.), а рёбра — связи между ними;
     - поддерживает специальные элементы `Mux2`, `Register`, `Fifo` для организации потоков данных и хранения состояния;
     - выполняет вычисления, пропуская значения через граф и учитывая блокировки на FIFO.
   - **Стековая ВМ Harv (`vm/harv`)**:
     - реализует классическую стековую машину с таблицей переменных, системой типов и набором инструкций;
     - использует FIFO‑очереди для взаимодействия с внешним миром и другими узлами;
     - отделяет фазу инициализации от основной фазы выполнения.

3. **Сетевая ВМ (`vm/network`)**
   - Интерпретирует мета‑секцию пакета `SOLP` как описание сети Кана:
     - узлы с типами, портами и привязками к контейнерам `SOLB`;
     - соединения между конкретными портами узлов.
   - На базе этих данных строит структуру `BuiltNetwork`, содержащую:
     - каналы для всех соединений и self‑портов;
     - набор узловых ВМ, созданных через выбранную фабрику (`StubNodeVmFactory`, `SimNodeVmFactory`, `HarvNodeVmFactory`, `MixedNodeVmFactory`);
     - вспомогательные компоненты для sniff‑режима и записи CSV‑логов.
   - Запускает каждый узел в отдельной корутине, обеспечивая параллельное исполнение и обмен данными только через FIFO.

Логически архитектура обеспечивает слабую связанность компонентов:

- компилятор не знает о деталях реализации ВМ и лишь формирует согласованный бинарный формат;
- узловые ВМ не знают о структуре всей сети и работают только с локальными портами и очередями;
- сетевая ВМ отвечает за связывание узлов и организацию коммуникации, абстрагируясь от внутреннего байткода.

## Поток данных от исходника к выполнению

Архитектурно жизненный цикл программы на Solace можно представить в виде последовательности шагов:

1. **Парсинг и анализ**:
   - исходный текст `*.solace` разбирается по грамматике ANTLR;
   - строится AST, на основе которого выполняется анализ сети и проверка корректности.
2. **Генерация байткода**:
   - для каждого аппаратного узла формируется список инструкций симулятора и кодируется в строку/байты;
   - для каждого программного узла формируется список инструкций Harv и аналогично кодируется.
3. **Упаковка в пакет**:
   - строится таблица строк с именами узлов и портов;
   - формируется поток инструкций `NODE_DEF`/`CONNECT`, описывающий структуру сети;
   - в конец файла последовательно добавляются контейнеры `SOLB` с байткодом узлов.
4. **Загрузка и построение сети**:
   - сетевая ВМ читает заголовок `SOLP`, таблицу строк и поток инструкций;
   - создаёт структуру `BuiltNetwork` с узлами, портами и каналами.
5. **Запуск узловых ВМ**:
   - выбранная фабрика ВМ создаёт конкретные экземпляры узловых ВМ (симулятор, Harv или заглушка);
   - каждая ВМ запускается в отдельной корутине, обмен данными осуществляется через каналы.

Такое разделение позволяет независимо развивать язык, форматы файлов и реализации виртуальных машин.

## Модель параллелизма и синхронизации

Solace исходит из модели, где каждый узел — это независимый параллельный процесс, взаимодействующий с другими узлами только через FIFO‑каналы:

- каждый узел исполняется в собственной корутине Kotlin;
- на уровне сети Кана отсутствует общая память: состояние хранится внутри узлов и в self‑очередях;
- блокирующие операции `read$` и `write <-` служат единственным механизмом синхронизации.

Это облегчает рассуждение о параллельных программах: отсутствие общей памяти снижает риск гонок, а использование FIFO‑очередей делает явными все точки взаимодействия между компонентами сети.

## Пример смешанной сети (Fibonacci)

В каталоге `examples` приведён пример смешанной программы `fibonacci_mixed.solace`, иллюстрирующий совместную работу аппаратных и программных узлов:

- `TickSource : hardware` — аппаратный узел‑источник тактов:
  - в блоке `init` помещает начальное значение в self‑очередь `loop`;
  - в блоке `run` на каждом шаге увеличивает счётчик и отправляет его в выходной порт `tick`, одновременно обновляя `loop`.
- `FibStepper : software` — программный узел, вычисляющий числа Фибоначчи:
  - использует вход `step` как «тактирующий» сигнал (чтение из FIFO блокирует выполнение до прихода данных);
  - хранит два последних значения последовательности в self‑очередях `prev` и `curr`;
  - на каждом шаге вычисляет следующее число и отправляет его в порт `fib`.
- `FibPrinter : software` — программный узел‑потребитель:
  - читает входной порт `inFib`;
  - выводит текущее значение при помощи операции `print`.

Секция `network` соединяет эти узлы в конвейер:

- `TickSource.tick -> FibStepper.step;`
- `FibStepper.fib -> FibPrinter.inFib;`

На уровне архитектуры данный пример демонстрирует:

- использование аппаратного узла для генерации событий/тактов;
- реализацию состояния и логики на программной стороне (Harv);
- передачу данных и синхронизацию исключительно через FIFO‑очереди.

\newpage

# Описание реализации

## Компилятор (`compiler`)

Реализация компилятора включает следующие ключевые элементы:

- использование ANTLR‑генерируемых классов `SolaceLexer` и `SolaceParser` для получения AST;
- модуль анализа сети (`analyzeProgram`), который:
  - извлекает из AST список узлов, их типы и сигнатуры портов;
  - строит модель соединений;
  - выполняет набор проверок корректности (уникальность имён, отсутствие конфликтов портов и соединений, использование портов);
  - при обнаружении ошибок выбрасывает `ValidationException` с информативными сообщениями;
- генераторы байткода:
  - `HardwareVisitor` — обходит аппаратные узлы, формируя последовательности инструкций для симулятора; инструкции кодируются функцией `AsmParser.encodeInstructions` в строковое представление и далее в байты;
  - `SoftwareVisitor` — аналогично обходит программные узлы, генерируя инструкции для стековой машины Harv;
- упаковщик пакетного файла:
  - строит таблицу строк (имена узлов и портов, используемых в топологии);
  - формирует поток инструкций `NODE_DEF`/`CONNECT`, вычисляя смещения и размеры контейнеров `SOLB`;
  - записывает заголовок `SOLP`, таблицу строк, поток инструкций и далее блоки байткода;
  - проверяет корректность размеров и типов узлов при упаковке.

Отдельно специфицирован формат выходных файлов (`FILE_FORMATS.md`), фиксирующий бинарный протокол взаимодействия компилятора и ВМ.

### Формат выходных файлов компилятора

Документ `FILE_FORMATS.md` подробно описывает два ключевых формата:

1. **Пакет `SOLP` (`*.solpkg`)**:
   - заголовок фиксированной длины с полями `magic`, версия контейнера, флаги, размер мета‑секции и количество узлов;
   - мета‑секция, состоящая из:
     - таблицы строк (`string_count` и последовательность записей `length + bytes`);
     - потока инструкций, каждая из которых кодирует либо объявление узла (`NODE_DEF`), либо соединение (`CONNECT`), завершаемого байтом `END (0xFF)`;
   - секция байткода, содержащая контейнеры `SOLB` для каждого узла.
2. **Контейнер байткода `SOLB`**:
   - заголовок с полями `magic`, версия, тип узла, версия ISA, флаги, размеры секций `init` и `run`;
   - последовательность байтов `init`, за которой следует последовательность байтов `run`.

Компилятор строго следует этой спецификации, вычисляя смещения и размеры блоков и проверяя, что фактическая длина записанных инструкций совпадает с расчётной. Это позволяет сетевой ВМ однозначно интерпретировать содержимое файла и надёжно извлекать байткод узлов.

## Сетевая ВМ (`vm/network`)

Основные компоненты реализации:

- загрузчик пакета:
  - проверяет заголовок `SOLP`, версии и размеры;
  - читает таблицу строк и поток инструкций, восстанавливая описание узлов и соединений;
  - для каждого узла определяет смещение и размер соответствующего контейнера `SOLB`.
- строитель сети (`buildNetwork`):
  - по описанию узлов создаёт структуру `NetworkNode` с портами и каналами;
  - для каждого соединения создаёт канал FIFO, а для каждого self‑порта — отдельный канал с разветвлением на вход/выход;
  - при активированном sniff‑режиме вставляет промежуточные каналы `wire`/`deliver` и корутины‑наблюдатели, пишущие трафик в лог или CSV.
- фабрики узловых ВМ:
  - `StubNodeVmFactory` создаёт заглушки, проверяющие корректность подключения портов и периодически сообщающие о «живости» узла;
  - `SimNodeVmFactory` парсит контейнеры `SOLB` для аппаратных узлов, создаёт симуляторы и управляет их запуском, обмениваясь данными через FIFO;
  - `HarvNodeVmFactory` и `MixedNodeVmFactory` связывают сетевую ВМ со стековой машиной Harv и обеспечивают смешанный режим исполнения.
- управляющая логика (`runNetwork`):
  - создаёт корутины для всех узлов, запускает их и по необходимости завершает работу сети по таймауту;
  - корректно останавливает sniffer‑задачи и закрывает ресурсы (файлы CSV и т. п.).

### Sniff‑режим и CSV‑логирование

Отдельного внимания заслуживает реализация наблюдения за трафиком в сети:

- при отключённом sniff‑режиме:
  - для каждого соединения создаётся один буферизованный канал, используемый и отправителем, и получателем;
- при включённом sniff‑режиме:
  - создаются два канала: `wire` (канал «провода») и `deliver` (канал доставки);
  - в отдельной корутине запускается sniffer, который:
    - считывает значения из `wire`;
    - при активной настройке sniff‑режима:
      - печатает сообщения в текстовом формате `[sniff] A.out -> B.in: value`;
      - или записывает строки в CSV‑формате `from_node,from_port,to_node,to_port,value`;
      - соблюдает ограничение по числу записей, отключая вывод при достижении лимита;
    - пересылает каждое значение далее в канал `deliver`.

Такой подход позволяет прозрачно «подключить осциллограф» к любому соединению в сети, не изменяя логику узловых ВМ и не вмешиваясь в формат пакетного файла.

## Симулятор (`vm/sim`)

Реализация симулятора аппаратных узлов основана на классе `NetlistGraph`, представляющем вычислительную схему как граф элементов и соединений. Поддерживаются:

- базовые элементы (арифметические, логические, сдвиги, сравнения);
- специальные элементы `Register`, `Mux2`, `Fifo` для организации состояния и ветвления потоков данных;
- FIFO‑очереди, используемые для взаимодействия с другими ВМ и для реализации self‑портов.

Выполнение симулятора заключается в пошаговом распространении значений по графу с учётом зависимостей и наличия/отсутствия данных во входных FIFO. При нехватке данных симулятор возвращает статус `BLOCKED`, при успешном завершении шага — `SUCCESS`, при ошибках — `ERROR`.

Особенность модели комбинационной логики в том, что большую часть схемы можно рассматривать как чистую функцию от входов к выходам. Элементы `Register` и self‑FIFO вносят во взаимодействие «память», позволяя строить последовательные схемы (счётчики, генераторы импульсов, фильтры), которые эволюционируют от такта к такту. Компилятор для hardware‑узлов генерирует для симулятора набор инструкций, которые фактически описывают, как из исходного кода Solace построить и обновлять такой граф.

## Стековая ВМ Harv (`vm/harv`)

Основной класс `StackMachine` инкапсулирует:

- стек значений;
- таблицу переменных и их типов;
- таблицу меток;
- список инструкций и счётчик команд.

Двухфазное исполнение реализовано методами `tryInit` (инициализационная фаза) и `tryRun` (основная фаза). Парсер `AsmParser` обеспечивает:

- преобразование текстового представления инструкций в закодированный байткод;
- обратное декодирование байткода в список инструкций;
- разбор инструкций в объекты с общим интерфейсом `Instruction`.

Инструкции покрывают арифметику, сравнения, логику, работу со стеком, управление выполнением, определение переменных, работу с FIFO (`pushsize`, операции чтения/записи) и вывод (`print`). FIFO реализованы как отдельный тип `HarvFifo` с блокирующим поведением: при попытке чтения из пустой очереди машина возвращает статус `BLOCKED`.

Текстовый синтаксис инструкций Harv унифицирован и использует префиксы:

- `.` — начало инструкции (`.define`, `.push`, `.add` и т. д.);
- `%` — указание типа значения (`%int`, `%string`, `%fifo`);
- `$` — имя переменной или FIFO‑очереди;
- `#` — целочисленный литерал;
- `+` — строковый литерал;
- `?` — пометка инструкций, относящихся к инициализационной фазе.

AsmParser поддерживает несколько режимов:

- кодирование списка инструкций из текстового вида в компактный бинарный вид;
- обратную декодировку бинарного байткода в список инструкций (для отладки и тестирования);
- парсинг текста непосредственно в объекты `Instruction`, которые затем исполняются `StackMachine`.

Такая архитектура парсера позволяет экспериментировать с форматами хранения программ (текст/бинарный) без изменения логики самой виртуальной машины.

\newpage

# Описание тестов

Тестирование системы Solace организовано на нескольких уровнях.

## Тесты компилятора

Тесты модуля `compiler` расположены в `compiler/src/test/kotlin/solace/compiler` и включают:

- `ParserConstructsTest` — проверяет корректный разбор конструкций языка, включая:
  - выражения и управляющие конструкции (`if`, логические операции, сдвиги, унарные операции);
  - аппаратные конструкции для чтения/записи FIFO;
  - объявление сети и соединений между узлами;
  - минимальные узлы без портов.
- `NetworkAnalysisTest` — тестирует семантический анализ сети:
  - успешную сборку топологии для корректных программ;
  - обработку ошибок при ссылках на неизвестные узлы, дублирующих соединениях и портах, неиспользованных портах.
- `HardwareVisitorTest` — проверяет:
  - корректность генерации байткода для аппаратных узлов;
  - выполнение этого байткода симулятором, статусы исполнения и содержимое FIFO.
- `SoftwareVisitorTest` — аналогично проверяет генерацию и исполнение байткода для программных узлов на стековой ВМ.
- `PackagingIntegrationTest` — интеграционный тест полного конвейера:
  - компиляция небольшой сети в `*.solpkg`;
  - загрузка пакета сетевой ВМ;
  - запуск сети и проверка ожидаемого поведения на выходах.

Таким образом, тесты компилятора покрывают весь путь от исходного кода до исполняемого пакетного файла и его интерпретации сетевой ВМ.

## Тесты симулятора (`vm/sim`)

Для симулятора аппаратных узлов тестируются:

- корректность построения и расчёта графа `NetlistGraph`;
- корректность работы парсера инструкций и преобразований между байткодом и объектами Kotlin;
- выполнение примеров программ, сгенерированных компилятором или написанных на ассемблероподобном языке;
- механизмы блокировки при недостатке данных во входных FIFO.

Также тестируется связка «компилятор → симулятор»: программы на языке Solace компилируются в байткод, загружаются в симулятор и сравниваются ожидаемые и фактические результаты вычислений.

## Тесты стековой ВМ Harv (`vm/harv`)

Тесты стековой машины сосредоточены на:

- проверке блокирующего поведения FIFO (чтение из пустой очереди даёт статус `BLOCKED`, после поступления данных выполнение продолжается);
- корректности реализации счётчиков и циклических конструкций с использованием FIFO для хранения состояния;
- верификации сериализации и обратного парсинга инструкций (тесты `round‑trip` для всех типов инструкций).

## Тесты сетевой ВМ (`vm/network`)

Сетевая ВМ тестируется с точки зрения:

- корректного чтения и валидации пакетов формата `SOLP`;
- построения сети Кана по инструкциям `NODE_DEF`/`CONNECT`;
- корректного связывания узловых ВМ с каналами и self‑портами;
- работы различных фабрик ВМ и режимов sniff/CSV‑логирования.

Отдельные интеграционные тесты демонстрируют, что сетевая ВМ способна запускать смешанные сети из аппаратных и программных узлов, корректно передавая значения по FIFO‑каналам.

\newpage

# Вывод

В рамках проекта Solace реализована экспериментальная платформа для моделирования вычислений на основе сети Кана, объединяющая язык описания узлов и сети, компилятор и набор виртуальных машин. Предложенная архитектура чётко разделяет ответственность между компонентами: компилятор отвечает за анализ и упаковку программы в единый бинарный формат, узловые ВМ реализуют конкретные модели вычислений (комбинационная логика и стековая машина), а сетевая ВМ строит и исполняет сеть, обеспечивая взаимодействие узлов через FIFO‑каналы.

Реализация сопровождается достаточно подробной спецификацией форматов выходных файлов и комплексным набором модульных и интеграционных тестов, проверяющих корректность парсинга, анализа сети, генерации байткода и исполнения программ. Это создаёт основу для дальнейшего развития системы: расширения языка, добавления новых типов узловых ВМ, экспериментирования с альтернативными моделями вычислений и интеграции с реальными встраиваемыми и распределёнными системами.

\newpage
