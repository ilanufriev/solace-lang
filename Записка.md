# Записка

## 1. Общая архитектура

Есть три слоя:

1. **Язык / компилятор**

   * Читает `.solace`.
   * Разбирает синтаксис (ANTLR).
   * Генерирует байткод для каждого узла.
   * Записывает на диск:

     * отдельные файлы байткода для узлов;
     * один «мета-файл» программы с описанием сети.

2. **ВМ узлов (hardware / software)**

   * Умеют читать свои файлы байткода.
   * Интерпретируют команды байткода, выполняя логику узла.

3. **ВМ сети Кана**

   * Читает мета-файл программы.
   * Создаёт каналы между узлами (Kahn network).
   * Запускает каждую ВМ узла в своей корутине.
   * Обеспечивает блокирующее чтение из каналов и неблокирующую запись.

---

## 2. Что делает компилятор

### 2.1. Разбор исходника

Компилятор:

1. Читает исходный `.solace`.
2. Парсит его по грамматике:

   * собирает описание всех `node` (имя, тип: `hardware`/`software`, сигнатуры `in/out/self`, блоки `init` и `run`);
   * собирает описание глобального `network` (список соединений `NodeA.portX -> NodeB.portY`).

На этом шаге можно считать, что получена некая внутренняя структура «программа»:

* список узлов;
* список соединений.

### 2.2. Проверка сети

Перед генерацией байткода компилятор:

* проверяет, что каждый узел, который фигурирует в `network`, реально объявлен;
* проверяет, что:

  * в соединении источник — это существующий выходной порт (`out`) узла-источника;
  * приёмник — существующий входной порт (`in`) узла-получателя.

Если что-то не сходится, компилятор выдает ошибку ещё до генерации байткода.

### 2.3. Бэкенды для разных ВМ

Для генерации байткода удобно разделить:

* бэкенд для **hardware**-узлов (комбинаторная логика);
* бэкенд для **software**-узлов (стековая машина).

Каждый бэкенд умеет:

* принять дерево / представление блока `init { ... }`;
* принять дерево / представление блока `run { ... }`;
* на выходе отдать некоторую последовательность байтов:

  * байткод `init`;
  * байткод `run`.

Важно: бэкенд hardware знает набор своих опкодов, стек, регистры, семантику операций; бэкенд software — свой набор опкодов и стек.

### 2.4. Выгрузка результата на диск

Результат компиляции — **не один файл**, а небольшой каталог, условно:

* подкаталог с файлами байткода узлов;
* один текстовый мета-файл программы (например, в JSON или другом простом формате).

Содержание:

1. Для каждого узла:

   * имя узла;
   * тип (`hardware` или `software`);
   * имя файла байткода, который нужно потом загрузить ВМ.

   Сам файл байткода можно сделать так:

   * внутри сначала секция `init`;
   * потом секция `run`;
   * формат простой, чтобы ВМ легко разделила части.

2. Для сети:

   * массив соединений;
   * для каждого соединения:

     * имя узла-источника и имя его выходного порта;
     * имя узла-приёмника и имя его входного порта.

Таким образом, **компилятор полностью заканчивает работу на уровне файлов** и никак не зависит от корутин, каналов и т. д.

---

## 3. Что делает ВМ сети (Kahn network)

Когда есть подготовленный каталог с программой, в игру вступает запускающий слой.

### 3.1. Загрузка программы

На вход ВМ сети подаётся путь к каталогу программы. Она:

1. Читает мета-файл:

   * получает список узлов (имя, тип, путь к байткоду);
   * получает список соединений (описание графа сети).

2. По мета-файлу загружает байткод каждого узла из соответствующего файла:

   * получает два массива байт: байткод `init` и `run` для узла.

В этот момент ВМ сети знает:

* полный список «нод» и для каждой:

  * тип (какую конкретную ВМ узла создавать);
  * байткод для инициализации;
  * байткод для основного цикла;
* полную топологию сети Кана.

### 3.2. Построение каналов

Далее ВМ сети:

1. Для каждого соединения `A.port1 -> B.port2` создаёт отдельный канал «очередь FIFO».
2. Для каждого узла строит три набора портов:

   * входные: отображение имени входного порта → читающий конец канала;
   * выходные: имя выходного порта → пишущий конец канала;
   * self-порты: имя self-порта → отдельный FIFO-канал (обычно не участвует в глобальной сети, а замыкается на самого себя).

Итог: для каждого узла есть объект «порты узла», где по имени порта можно получить соответствующий канал (на чтение или запись).

### 3.3. Создание и запуск узловых ВМ

Теперь ВМ сети должна «включить» конкретные исполнители байткода:

1. Для каждого узла выбирается фабрика:

   * если тип `hardware` → фабрика создаёт экземпляр «hardware-ВМ», умеющей исполнять именно такой байткод;
   * если тип `software` → другая фабрика, создающая стековую ВМ.

2. В фабрику передаются:

   * байткод `init`;
   * байткод `run`;
   * структура портов этого узла (входы, выходы, self-каналы).

3. В результате фабрика возвращает некий объект «узловая ВМ», у которой есть метод/операция «запустить».

4. ВМ сети запускает каждую узловую ВМ в отдельной корутине:

   * сначала исполнение байткода `init` один раз;
   * затем бесконечный цикл исполнения байткода `run`.

Главное: узловая ВМ сама во время интерпретации байткода обращается к портам:

* чтение `$fifo` превращается во **вызов блокирующего чтения** из соответствующего канала;
* операция `fifo <- expr` превращается в **вызов записи** в соответствующий канал;
* `$fifo?` — в какую-то неблокирующую или условную операцию, которую вы определите в семантике.

За счёт того, что чтение блокирующее, а в сети нет других источников недетерминизма, получаются стандартные свойства сети Кана.

---

## 4. Что делают конкретные ВМ узлов

Каждая из двух ВМ (hardware и software) знает только о:

* своём формате байткода;
* своих регистрах/стеке;
* том, как, глядя на опкод, выполнять:

  * арифметику;
  * логические операции;
  * операции над FIFO:

    * прочитать значение из входного порта;
    * записать значение в выходной порт;
    * работать с self-каналом;
  * управление потоком (условные переходы, циклы и т. п.).

Они **не знают**:

* ничего о файлах программы;
* ничего о структуре сети в целом;
* только то, какие порты есть у данного узла (через переданный объект «порты узла»).

---

## 5. Жизненный цикл программы

Итого, сценарий запуска:

1. Команда компиляции:

   * на вход: исходный файл языка Solace;
   * на выход: каталог программы:

     * файлы байткода узлов;
     * текстовый мета-файл программы (описание сети и узлов).

2. Команда запуска ВМ:

   * на вход: путь к каталогу программы;
   * ВМ сети:

     * читает мета-файл;
     * загружает байткод всех узлов;
     * строит каналы сети;
     * создаёт и запускает узловые ВМ в корутинах;
   * узловые ВМ:

     * выполняют `init`;
     * затем в бесконечном цикле выполняют `run`, взаимодействуя только через FIFO-каналы.

Так получается чистое разделение:

* **компилятор** занимается только анализом исходника и генерацией байткода + метаданных;
* **ВМ сети** занимается только топологией и каналами;
* **ВМ узлов** занимается только интерпретацией байткода и обращением к своим портам.

## СТЪПКИ ЗА ИЗПЪЛНЕНИЕ

Тогда лучше всего сделать **один бинарный контейнер**, внутри которого:

* одна секция с JSON-метаданными (описание сети);
* несколько секций с байткодом узлов.

Парсер у ВМ сети будет очень простой: «прочитал заголовок, потом читаю чанки по очереди».

Ниже — конкретный формат.

---

## 1. Общая структура одного файла

Файл, например, `program.slnet`:

```text
[FileHeader]
[Chunk]*
```

### 1.1. Заголовок файла

```c
struct FileHeader {
    uint8  magic[4];    // 'S','L','N','T'  (SoLace NeTwork)
    uint8  version;     // версия формата контейнера
    uint8  reserved[3]; // 0, на будущее
};
```

Парсер:

1. читаешь 8 байт;
2. проверяешь `magic == "SLNT"`;
3. проверяешь, что `version` поддерживается.

### 1.2. Чанк (общий формат)

Дальше идёт просто поток чанков (TLV):

```c
struct ChunkHeader {
    uint8  kind;    // тип чанка
    uint8  flags;   // пока 0, на будущее
    uint16 reserved;
    uint32 size;    // длина payload в байтах
    // далее size байт полезных данных
};
```

Типы чанков:

* `1` — `META_JSON` (описание сети в JSON);
* `2` — `NODE` (байткод одного узла);
* в будущем можно добавить:

  * `3` — глобальные константы;
  * `4` — build-info и т. п.

Парсинг общего уровня:

```pseudo
read FileHeader
while not EOF:
    read ChunkHeader ch
    payload = read_bytes(ch.size)
    switch ch.kind:
        case 1: meta_json_payloads.append(payload)
        case 2: node_payloads.append(payload)
        default: skip / запомнить на будущее
```

---

## 2. META_JSON: описание сети в одном чанке

Payload чанка `kind = 1` — просто UTF-8 JSON:

```json
{
  "format_version": 1,
  "nodes": [
    { "name": "Filter", "vm_kind": "software" },
    { "name": "UartRx", "vm_kind": "hardware" }
  ],
  "connections": [
    { "from": ["UartRx", "out"], "to": ["Filter", "in"] }
  ]
}
```

Здесь можно:

* либо дублировать `vm_kind` узла (для удобства проверки на уровне сети);
* либо считать его «истиной» из самого NODE-чанка, а в JSON — только имя узла и порты.

Парсер META_JSON у ВМ:

```pseudo
meta = json.parse(meta_payload)
network_nodes = meta.nodes
network_connections = meta.connections
```

---

## 3. NODE: байткод одного узла

Payload чанка `kind = 2` — компактный бинарный блок:

```c
struct NodeChunkHeader {
    uint8  vm_kind;     // 0 = hardware, 1 = software
    uint8  reserved;
    uint16 name_len;    // длина имени в байтах (UTF-8)
    uint32 init_size;   // длина init-байткода
    uint32 run_size;    // длина run-байткода
    // далее:
    // [name_len байт имени]
    // [init_size байт init-кода]
    // [run_size байт run-кода]
};
```

Парсер одного NODE-чанка:

```pseudo
vm_kind, reserved, name_len, init_size, run_size = read_node_header(payload)
name  = read_bytes(name_len)
init  = read_bytes(init_size)
run   = read_bytes(run_size)

nodes_by_name[name] = { vm_kind, init, run }
```

То есть, всё, что нужно ВМ узла, уже есть внутри одного чанка:

* имя узла (чтобы сопоставить с описанием сети в META_JSON);
* тип ВМ (`hardware` / `software`);
* байткод `init` и `run`.

Если позже понадобятся константные/строковые пулы, можно:

* либо расширить `NodeChunkHeader` ещё парами `pool_size`;
* либо после `run` внутри payload добавить маленький TLV по тому же принципу (но это уже вторая стадия развития формата).

---

## 4. Как это использовать в твоей архитектуре

### 4.1. Что делает компилятор

Вместо каталога с кучей файлов компилятор теперь пишет один:

1. Строит JSON описания сети (как раньше для мета-файла).

2. Открывает `program.slnet`.

3. Пишет `FileHeader`.

4. Пишет чанк `META_JSON`:

   * считаем `payload = encode_utf8(json_string)`;
   * пишем `ChunkHeader(kind=1, size=len(payload))`;
   * пишем `payload`.

5. Для каждого узла:

   * компилирует в байткод `init`/`run`;
   * формирует `NodeChunkHeader` + имя + байткоды;
   * пишет `ChunkHeader(kind=2, size=... всего по NodeChunk)` + payload.

Готово: один файл.

### 4.2. Что делает ВМ сети

1. Открывает `program.slnet`.

2. Читает `FileHeader`.

3. В одном проходе собирает:

   * один `meta_json` (или последний, если их несколько — можно использовать как «слои»);
   * карту `nodes_by_name` из NODE-чанков.

4. Разбирает JSON, проверяет:

   * что все узлы из `connections` есть в `nodes_by_name`;
   * что типы/порты совпадают.

5. Строит каналы и создаёт ВМ узлов на основе `nodes_by_name[name]`.

---

## 5. Компрессия и «лёгкость парсинга»

Если нужен ещё и небольшой размер:

* можно сжимать **весь файл целиком** (например, `program.slnet.zst`):

  * ВМ сначала делает `decompress()`, получает чистый бинарный контейнер, дальше всё как описано;
* формат внутри остаётся максимально простым: фиксированные заголовки + последовательность чанков.

Почему это «легко парсится»:

* на верхнем уровне один цикл:

  ```pseudo
  read_header()
  while not EOF:
      ch = read_chunk_header()
      payload = read_bytes(ch.size)
      handle_chunk(ch.kind, payload)
  ```

* для байткода узла — тоже один линейный проход по payload;

* JSON — единственная «сложная» часть, но её парсит готовая библиотека.

Если хочешь, могу следующим шагом расписать конкретный формат `NodeChunkHeader` для hardware/software (какие именно поля под регистры, стек и т. п.), но это уже другой уровень детализации.
