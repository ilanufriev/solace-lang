# Solace

Solace — экспериментальный язык программирования и набор виртуальных машин для моделирования вычислений на основе:

- [комбинаторной логики (hardware-узлы)](vm/sim/README.md);
- стековой машины (software-узлы);
- сетей Кана (network), управляющих взаимодействием всех узлов.

Язык описывается грамматикой ANTLR4 (`Solace.g4`) и исполняется на трёх VM, реализованных на Kotlin (с использованием корутин и каналов для сети Кана).

---

## Концепция

1. **Узел (node)** — единица вычисления. Бывает двух типов:
   - `hardware` — модель комбинаторной логики;
   - `software` — модель стековой машины.

2. У каждого узла есть:
   - сигнатура каналов: `in`, `out`, `self` (петля);
   - две секции кода:
     - `init { ... }` — выполняется один раз при старте;
     - `run  { ... }` — запускается в бесконечном цикле.

3. **Сеть Кана (`network`)**:
   - описывает соединения между каналами узлов;
   - в языке существует одна глобальная сеть;
   - сеть задаёт топологию обмена данными.

4. **Три уровня**:
   - фронтенд: язык Solace → AST (ANTLR4);
   - бэкенд: AST → байткод для конкретной VM;
   - рантайм: запуск сети и узлов на Kotlin (каждый узел — корутина, ребро сети — канал).

## Узлы, каналы и операции

### 1. Узлы (`node`)

Два типа узлов:

- `hardware` node
- `software` node

Общее для обоих типов:

- FIFO-очереди для обмена данными:
  - `write <-` — запись в FIFO
  - `read$` — чтение из FIFO
- Инициализация:
  - `init` выполняется один раз при запуске (аналог `setup` в Arduino).

### 2. Hardware-узел

- **Типы данных:** `int`.
- **Аритметика:** `+`, `-`, `*`, `/`.
- **Логика:** `!`, `&&`, `||`.
- **Битовые операции:** `<<`, `>>`.
- **Поток исполнения:** `if` для условных веток.
- **FIFO-ввод/вывод:** `write <-` (запись), `read$` (чтение).
- **Блокировка:** `read$` — блокирующее чтение (ждёт, если FIFO пусто); `write <-` может блокироваться при переполнении, синхронизация идёт через сами каналы.

### 3. Software-узел

- **Типы данных:** `int`, `string`.
- **Ввод/вывод:** `print` для логов/отладки/общения с внешним миром.
- **FIFO-ввод/вывод:** `write <-`, `read$`.
- **Аритметика:** `+ - * /` над `int`; опционально `+` для конкатенации `string`.
- **Логика:** `! && ||`.
- **Поток исполнения:** `if`.

### 4. Network

Компонент `network` задаёт схему соединения FIFO между узлами.

- Определяет топологию: какие `write`-выходы соединены с какими `read$`-входами.
- Узлы (`hardware`/`software`) — вершины графа, FIFO-каналы — ориентированные рёбра.

### 5. Что даёт такая модель

1. **Параллельные/распределённые процессы:** каждый узел — независимый процесс с собственным состоянием и обменом по FIFO.
2. **Совместное проектирование hardware/software:** первый ближе к аппаратной логике, второй — к обычному коду со строками/печатью.
3. **Синхронизация через каналы:** блокирующие `read$`/`write <-` дают синхронизацию без общей памяти.
4. **Выразительность:** примитивы арифметики, логики, условий и FIFO позволяют строить конвейеры, протоколы обмена, управляющие алгоритмы и взаимодействие ПО с виртуальным «железом».

---

[**Пример программы**](pseudocode.solace)

## Дополнительно

- [Формат выходных файлов компилятора](FILE_FORMATS.md)
- Сборка демо-пакета: `./gradlew :compiler:run --args "path/to/program.solace --out build/solace"`
  - На выходе появится `build/solace/program.solpkg` с мета-инструкциями и заглушечным байткодом для всех узлов.
  - Если запускаете из каталога `compiler`, указывайте путь относительно корня репозитория (например, `../pseudocode.solace`); CLI также попробует найти файл на уровень выше.
- Запуск «немой» сети: `./gradlew :vm:network:run --args "build/solace/program.solpkg"`
  - Загружает пакет, строит сеть Кана, создаёт заглушки hardware/software ВМ и логгирует их «живость» в корутинах.