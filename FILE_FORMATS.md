# Формат выходных файлов

Документ фиксирует, что именно компилятор пишет на диск и как это читает ВМ. Никакой реализации пока нет — это словесная спецификация и минимальные примеры.

---

## Единый файл программы (`*.solpkg`)

- Компилятор выпускает **один бинарный пакет**, содержащий метаданные и байткод всех узлов.
- Вёрстка в файле: `[заголовок пакета][мета-секция (инструкции сети)][блоки байткода узлов]`.
- Все числовые поля в заголовках — little-endian, строки в таблице строк — UTF-8.
- Смещения и размеры считаются от начала файла.

### Заголовок пакета (16 байт, little-endian)

| Смещение | Размер | Поле                | Значение                                              |
|----------|--------|---------------------|-------------------------------------------------------|
| 0        | 4      | `magic`             | ASCII `"SOLP"`                                        |
| 4        | 1      | `container_version` | `0x01` (версия упаковки программы)                    |
| 5        | 1      | `flags`             | зарезервировано, сейчас `0`                           |
| 6        | 2      | `reserved`          | `0x0000`                                              |
| 8        | 4      | `meta_size`         | длина мета-секции (инструкций сети) в байтах          |
| 12       | 4      | `node_count`        | количество узлов (дублирует информацию в мета-секции) |

Сразу после заголовка идёт мета-секция длиной `meta_size`. Следом — подряд бинарные блоки байткода узлов в произвольном порядке. Выравнивание не требуется, если оно не отражено в смещениях.

### Мета-секция: инструкции сети Кана

Секция делится на две части: таблица строк и поток инструкций. Идея: минимальный набор команд, чтобы построить сеть Кана и привязать байткод узлов.

1) **Таблица строк**

- `u32 string_count`
- `string[string_count]`: каждая строка — `u16 byte_length` + `byte[byte_length]` (UTF-8, без нуль-терминатора).
- Строки индексируются от `0`.

1) **Поток инструкций**

- Инструкции идут подряд до опкода `END (0xFF)`.
- Все идентификаторы узлов/портов — индексы в таблице строк.
- Смещения/размеры байткода — абсолютные (от начала файла), соответствуют контейнерам `solbc`.

Опкоды (версия 1):

| Код  | Имя        | Назначение                 |
|------|------------|----------------------------|
| 0x01 | `NODE_DEF` | Объявить узел и байткод    |
| 0x02 | `CONNECT`  | Соединить два порта        |
| 0xFF | `END`      | Завершить поток инструкций |

`NODE_DEF (0x01)` — объявление узла и привязка к блоку байткода  

| Поле           | Тип  | Значение/комментарий                         |
|----------------|------|----------------------------------------------|
| `node_name_id` | u16  | Индекс строки имени узла (уникален в пакете) |
| `node_type`    | u8   | `0=hardware`, `1=software`                   |
| `in_count`     | u8   | Количество входов                            |
| `in_name_id`   | u16* | `in_count` индексов строк имён входов        |
| `out_count`    | u8   | Количество выходов                           |
| `out_name_id`  | u16* | `out_count` индексов строк имён выходов      |
| `self_count`   | u8   | Количество самосвязей                        |
| `self_name_id` | u16* | `self_count` индексов строк имён самосвязей  |
| `bc_offset`    | u32  | Смещение контейнера `solbc` в файле          |
| `bc_size`      | u32  | Длина контейнера `solbc` в байтах            |
| `bc_format`    | u8   | Формат байткода (`1=solbc`)                  |

Правила: `node_name_id` уникален; внутри узла имена портов не повторяются; `bc_offset`/`bc_size` должны указывать на контейнер `solbc`; `bc_format` сейчас только `1`; после инструкции узел добавляется в таблицу узлов по `node_name_id`.

`CONNECT (0x02)` — соединение порта `from` с портом `to`  

| Поле           | Тип | Значение                   |
|----------------|-----|----------------------------|
| `from_node_id` | u16 | Строка: имя узла-источника |
| `from_port_id` | u16 | Строка: имя его порта      |
| `to_node_id`   | u16 | Строка: имя узла-приёмника |
| `to_port_id`   | u16 | Строка: имя его порта      |

Правила: упомянутые узлы должны быть объявлены через `NODE_DEF` (желательно раньше по потоку); все поля — ссылки на строки таблицы; порт должен существовать в `in/out/self` соответствующего узла.

`END (0xFF)` — завершение потока инструкций; всё, что дальше в файле, трактуется как байткод узлов.

`node_count` в заголовке должен совпадать с числом `NODE_DEF` в потоке; при несовпадении загрузчик может отвергнуть файл.

Пример инструкций (псевдо-дамп):

```text
string table (6, little-endian):
 06 00 00 00                          ; u32 string_count = 6
 06 00 53 65 6e 73 6f 72              ; "Sensor"
 0a 00 43 6f 6e 74 72 6f 6c 6c 65 72  ; "Controller"
 04 00 64 61 74 61                    ; "data"
 03 00 63 6d 64                       ; "cmd"
 05 00 73 6f 6c 62 63                 ; "solbc"
 00 00                                ; "" (пустая строка)

resolved indices:
 0:"Sensor"
 1:"Controller"
 2:"data"
 3:"cmd"
 4:"solbc"
 5:""

instructions:
 01 0000 00 00 01 0002 00 00000080 00000013 01
    ^    ^  ^  ^  ^   ^   ^        ^        ^
    |    |  |  |  |   |   |        |        +-- bc_format=1 (solbc)
    |    |  |  |  |   |   |        +----------- bc_size=0x13 bytes
    |    |  |  |  |   |   +-------------------- bc_offset=0x80
    |    |  |  |  |   +------------------------ self_count=0
    |    |  |  |  +---------------------------- out_name_id[0]=2 ("data")
    |    |  |  +------------------------------- out_count=1
    |    |  +---------------------------------- in_count=0 (нет входов)
    |    +------------------------------------- node_type=0 (hardware)
    +------------------------------------------ node_name_id=0 ("Sensor")
    OPCODE: NODE_DEF

 01 0001 01 01 0002 01 0003 00 00000093 00000013 01
    ... NODE_DEF Controller SW, in=data (2), out=cmd (3), bc_offset=0x93 size=0x13

 02 0000 0002 0001 0002
    ^    ^    ^    ^
    |    |    |    +-- to_port_id="data" (2)
    |    |    +------- to_node_id="Controller" (1)
    |    +------------ from_port_id="data" (2)
    +----------------- from_node_id="Sensor" (0)

 FF                                           ; END
```

### Блоки байткода узлов в пакете

- Каждому узлу соответствует один бинарный блок формата `solbc`.
- Блоки идут подряд после мета-секции; порядок не важен, смещения/размеры зафиксированы в инструкциях `NODE_DEF`.
- Допускается выравнивание блоков (например, до 4 или 8 байт) — главное, чтобы `offset` указывал на фактическое начало контейнера.

---

## Контейнер байткода узла (`solbc`)

Используется и для hardware-, и для software-узлов; отличается только набором опкодов внутри секций. Контейнер может храниться как отдельный файл или как встроенный блок внутри `*.solpkg`.

### Заголовок контейнера (16 байт, little-endian)

| Смещение | Размер | Поле                | Значение                                         |
|----------|--------|---------------------|--------------------------------------------------|
| 0        | 4      | `magic`             | ASCII `"SOLB"`                                   |
| 4        | 1      | `container_version` | `0x01` (версия контейнера)                       |
| 5        | 1      | `node_type`         | `0 = hardware`, `1 = software`                   |
| 6        | 1      | `isa_version`       | версия опкодов конкретной ВМ (стартуем с `0x01`) |
| 7        | 1      | `flags`             | зарезервировано, сейчас `0`                      |
| 8        | 4      | `init_size`         | длина секции init в байтах                       |
| 12       | 4      | `run_size`          | длина секции run в байтах                        |

После заголовка сразу идут тела секций:

```text
[init bytes ...]   // длина init_size (может быть 0)
[run bytes ...]    // длина run_size (может быть 0)
```

Замечания:

- `init` и `run` отделяются только длинами в заголовке, дополнительных маркеров нет.
- Если в исходнике секция не задана, её длина `0`.
- Проверка целостности пока не закладывается; при необходимости можно добавить CRC в конец файла, увеличив версию контейнера.
- Порты в байткод не дублируются — они описаны в мета-секции пакета.

Мини-дамп для примера (`init_size=3`, `run_size=2`, hardware):

```text
0000: 53 4f 4c 42 01 00 01 00 03 00 00 00 02 00 00 00  SOLB............
0010: AA BB CC DD EE                                    .....
```

Здесь `AA BB CC` — init, `DD EE` — run.
