# Формат выходных файлов

Документ фиксирует, что именно компилятор пишет на диск и как это читает ВМ. Никакой реализации пока нет — это словесная спецификация и минимальные примеры.

---

## Единый файл программы (`*.solpkg`)

- Компилятор выпускает **один бинарный пакет**, содержащий метаданные и байткод всех узлов.
- Вёрстка в файле: `[заголовок пакета][мета-секция (инструкции сети)][блоки байткода узлов]`.
- Все числовые поля в заголовках — little-endian, строки в таблице строк — UTF-8.
- Смещения и размеры считаются от начала файла.

### Заголовок пакета (16 байт, little-endian)

| Смещение | Размер | Поле                | Значение                                              |
|----------|--------|---------------------|-------------------------------------------------------|
| 0        | 4      | `magic`             | ASCII `"SOLP"`                                        |
| 4        | 1      | `container_version` | `0x01` (версия упаковки программы)                    |
| 5        | 1      | `flags`             | зарезервировано, сейчас `0`                           |
| 6        | 2      | `reserved`          | `0x0000`                                              |
| 8        | 4      | `meta_size`         | длина мета-секции (инструкций сети) в байтах          |
| 12       | 4      | `node_count`        | количество узлов (дублирует информацию в мета-секции) |

Сразу после заголовка идёт мета-секция длиной `meta_size`. Следом — подряд бинарные блоки байткода узлов в произвольном порядке. Выравнивание не требуется, если оно не отражено в смещениях.

### Мета-секция: инструкции сети Кана

Секция делится на две части: таблица строк и поток инструкций. Идея: минимальный набор команд, чтобы построить сеть Кана и привязать байткод узлов.

1) **Таблица строк**

- `u32 string_count`
- `string[string_count]`: каждая строка — `u16 byte_length` + `byte[byte_length]` (UTF-8, без нуль-терминатора).
- Строки индексируются от `0`.

1) **Поток инструкций**

- Инструкции идут подряд до опкода `END (0xFF)`.
- Все идентификаторы узлов/портов — индексы в таблице строк.
- Смещения/размеры байткода — абсолютные (от начала файла), соответствуют контейнерам `solbc`.

Опкоды:

- `0x01 NODE_DEF`  
  Поля: `u16 node_name_id`, `u8 node_type (0=hardware,1=software)`,  
  `u8 in_count`, `[u16 in_name_id] * in_count`,  
  `u8 out_count`, `[u16 out_name_id] * out_count`,  
  `u8 self_count`, `[u16 self_name_id] * self_count`,  
  `u32 bc_offset`, `u32 bc_size`, `u8 bc_format (1=solbc)`.

- `0x02 CONNECT`  
  Поля: `u16 from_node_id`, `u16 from_port_id`, `u16 to_node_id`, `u16 to_port_id`.

- `0xFF END` — завершение мета-секции.

`node_count` в заголовке должен совпадать с числом `NODE_DEF` в потоке; при несовпадении загрузчик может отвергнуть файл.

Пример инструкций (псевдо-дамп):

```text
strings (6):
 0:"Sensor" 1:"Controller" 2:"data" 3:"cmd" 4:"solbc" 5:""

code:
 01 0000 00 00 0000 00 0000 00 0000 00000080 00000013 01   ; NODE_DEF Sensor HW, out=data, bc at 0x80 size 0x13
 01 0001 01 01 0002 01 0003 00 0000 00000093 00000013 01   ; NODE_DEF Controller SW, in=data, out=cmd, bc at 0x93 size 0x13
 02 0000 0002 0001 0002                                     ; CONNECT Sensor.data -> Controller.data
 FF
```

### Блоки байткода узлов в пакете

- Каждому узлу соответствует один бинарный блок формата `solbc`.
- Блоки идут подряд после мета-секции; порядок не важен, смещения/размеры зафиксированы в инструкциях `NODE_DEF`.
- Допускается выравнивание блоков (например, до 4 или 8 байт) — главное, чтобы `offset` указывал на фактическое начало контейнера.

---

## Контейнер байткода узла (`solbc`)

Используется и для hardware-, и для software-узлов; отличается только набором опкодов внутри секций. Контейнер может храниться как отдельный файл или как встроенный блок внутри `*.solpkg`.

### Заголовок контейнера (16 байт, little-endian)

| Смещение | Размер | Поле                | Значение                                         |
|----------|--------|---------------------|--------------------------------------------------|
| 0        | 4      | `magic`             | ASCII `"SOLB"`                                   |
| 4        | 1      | `container_version` | `0x01` (версия контейнера)                       |
| 5        | 1      | `node_type`         | `0 = hardware`, `1 = software`                   |
| 6        | 1      | `isa_version`       | версия опкодов конкретной ВМ (стартуем с `0x01`) |
| 7        | 1      | `flags`             | зарезервировано, сейчас `0`                      |
| 8        | 4      | `init_size`         | длина секции init в байтах                       |
| 12       | 4      | `run_size`          | длина секции run в байтах                        |

После заголовка сразу идут тела секций:

```text
[init bytes ...]   // длина init_size (может быть 0)
[run bytes ...]    // длина run_size (может быть 0)
```

Замечания:

- `init` и `run` отделяются только длинами в заголовке, дополнительных маркеров нет.
- Если в исходнике секция не задана, её длина `0`.
- Проверка целостности пока не закладывается; при необходимости можно добавить CRC в конец файла, увеличив версию контейнера.
- Порты в байткод не дублируются — они описаны в мета-секции пакета.

Мини-дамп для примера (`init_size=3`, `run_size=2`, hardware):

```text
0000: 53 4f 4c 42 01 00 01 00 03 00 00 00 02 00 00 00  SOLB............
0010: AA BB CC DD EE                                    .....
```

Здесь `AA BB CC` — init, `DD EE` — run.
