# Сетевая ВМ: как это устроено

Этот модуль отвечает за загрузку пакета `*.solpkg`, построение сети Кана и запуск узловых ВМ (пока — заглушки).

## 1. Что загружаем

- Формат пакета описан в `FILE_FORMATS.md`: заголовок `SOLP`, таблица строк, поток инструкций (`NODE_DEF`, `CONNECT`, `END`) и встроенные контейнеры байткода `solbc`.
- `loader.kt`:
  - читает и валидирует заголовок, таблицу строк, инструкции;
  - собирает `LoadedProgram` со списком узлов (`LoadedNode`: имя, тип, сигнатура портов, байткод) и соединений;
  - проверяет, что каждый `solbc` имеет magic `SOLB`, подходящий тип узла и корректные размеры секций init/run.

## 2. Построение сети Кана

- `buildNetwork(program: LoadedProgram)` в `runtime.kt`:
  - для каждого узла создаёт карты портов и сразу заводит self‑каналы: `Channel<Any?>(UNLIMITED)` кладётся и во входы, и в выходы, и в `self`;
  - для каждого соединения `A.out -> B.in` создаёт отдельный `Channel<Any?>(UNLIMITED)`, кладёт его в outputs узла-источника и inputs узла-приёмника; следит, чтобы порт не был подключён дважды;
  - если порт объявлен, но не подключён, сейчас подставляется новый канал-заглушка (чтобы не было `null` в картах);
  - на выходе формирует `BuiltNetwork` со списком `NetworkNode`, каждый содержит `NodePorts` (inputs/outputs/self) и дескриптор узла.

## 3. Запуск узловых ВМ

- Контракт узла: `NodeVm` (`runtime.kt`) с методом `launch(scope: CoroutineScope): Job`.
- Фабрика: `NodeVmFactory` создаёт конкретную ВМ по `NetworkNode`.
- По умолчанию: `StubNodeVmFactory` (логгирует «alive» раз в N мс) для дымового теста сети.
- Расширение: `RealNodeVmFactory` в `vm_skeleton.kt` показывает, как разобрать `solbc` на init/run и вернуть hardware/software исполнителя (нужно дописать интерпретатор).
- Запуск: `BuiltNetwork.launch(scope, factory)` создаёт корутины для всех узлов. `runNetwork` — удобный helper, который строит сеть, запускает её со `StubNodeVmFactory` и ждёт завершения.

## 4. CLI

- `Main.kt`: `./gradlew :vm:network:run --args "path/to/program.solpkg"`.
- Путь ищется в текущей директории и родителях для относительных путей.

## 5. Где писать реальную логику

- Парсер/loader: `loader.kt` — если формат пакета изменится.
- Сеть/каналы: `runtime.kt` — если нужно менять буферизацию или обработку незадействованных портов.
- Узловые ВМ: `vm_skeleton.kt` (фабрика) + ваши реализации в модулях `vm/harv` (hardware) и `vm/sim` (software); там уже есть каркасы с доступом к каналам.
