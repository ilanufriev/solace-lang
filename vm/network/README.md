# Сеть Кана (network VM)

Этот модуль реализует «сетевую» виртуальную машину для языка Solace: он загружает скомпилированный пакет программы (`*.solpkg`), восстанавливает из него граф вычислительной сети (узлы и каналы между ними) и запускает узловые ВМ (stub‑ или simulator‑варианты), связывая их через асинхронные FIFO‑каналы.

## Введение

Сетевая ВМ — это слой поверх отдельных узловых ВМ, отвечающий не за исполнение байткода внутри узла, а за:

- чтение бинарного пакета программы (формат описан в `FILE_FORMATS.md`);
- восстановление списка узлов (hardware/software), их портов и соединений между ними;
- построение асинхронной сети каналов (по одному FIFO‑каналу на каждое соединение и self‑порт);
- запуск для каждого узла отдельной ВМ, которая взаимодействует только через объявленные порты.

Таким образом, модуль `vm/network` позволяет:

- проверять корректность собранного пакета (валидировать заголовки и контейнеры `solbc`);
- визуализировать топологию сети (выгрузка в Graphviz DOT);
- отлаживать поведение сети с помощью «немых» заглушек, sniff‑режима и симулятора.

## ТЗ (техническое задание)

Функциональные требования:

- Загрузка пакета программы формата `SOLP` с диска (по явно заданному пути или с поиском относительно текущего каталога вверх по дереву).
- Разбор мета‑секции: чтение таблицы строк, потока инструкций `NODE_DEF` и `CONNECT`, восстановление:
  - списка узлов с именем, типом (`HARDWARE`/`SOFTWARE`), сигнатурой портов (inputs/outputs/self);
  - списка соединений вида `from_node.from_port -> to_node.to_port`.
- Валидация пакетного формата:
  - проверка magic‑чисел (`SOLP` для пакета, `SOLB` для solbc‑контейнеров);
  - проверка размеров секций init/run и отсутствия выходов за пределы файла;
  - согласованность типа узла в метаданных и в solbc‑контейнере.
- Построение сети:
  - создание отдельных каналов FIFO для всех соединений;
  - создание self‑канала на каждый self‑порт узла и его «распараллеливание» на вход/выход;
  - строгая проверка наличия всех описанных в метаданных портов и запрет дублирующих подключений к одному и тому же входу/выходу.
- Запуск узловых ВМ:
  - поддержка stub‑фабрики (`StubNodeVmFactory`), создающей «немые» ВМ, лишь подтверждающие свою «живость»;
  - поддержка симуляторной фабрики (`SimNodeVmFactory`), использующей внутренний симулятор;
  - возможность задать длительность работы сети и остановить её по таймеру.
- Поддержка наблюдения за трафиком:
  - опция `--sniff` для вывода всех пересылаемых сообщений по каждому соединению;
  - опция `--sniff-csv`/`--sniff-csv-file` для логирования трафика в CSV (from_node,from_port,to_node,to_port,value) в файл или stdout;
  - ограничение числа записей на соединение через `--sniff-limit`.
- Экспорт топологии:
  - опция `--dot-out <file>` для выгрузки сети в формат DOT и выхода без запуска ВМ.

Нефункциональные требования:

- Безопасность по памяти: проверки границ при чтении бинарных структур, отказ при любых некорректных размерах/индексах.
- Диагностические сообщения при нарушениях формата, отсутствующих узлах/портах, рассинхронизации типов.
- Использование буферизованных каналов и корутин вместо блокирующих потоков, возможность ограничивать лог трафика.

Интерфейс командной строки (см. `Main.kt`):

- `solace-network <program.solpkg> [опции]`
- поддерживаемые опции:
  - `--dot-out <file>` — записать топологию в DOT‑файл и завершить;
  - `--sniff` — печатать трафик по всем соединениям;
  - `--sniff-csv` — логировать трафик в CSV (подразумевает `--sniff`);
  - `--sniff-csv-file <p>` — писать CSV в файл `<p>` (подразумевает `--sniff-csv`);
  - `--sniff-limit <n>` — максимум n сообщений на соединение;
  - `--sim` — запускать узлы через симуляторную ВМ вместо заглушек;
  - `--duration-ms <n>` — ограничить время работы сети n миллисекундами (по умолчанию: 5000 мс при sniff‑режиме, иначе «до Ctrl+C»);
  - `--help`, `-h` — вывести справку.

## Архитектура

Основные компоненты:

- `Main.kt`  
  CLI‑входная точка. Отвечает за:
  - разбор аргументов командной строки;
  - загрузку пакета (`loadProgramPackage`);
  - выбор режима работы (DOT‑выгрузка или полноценный запуск сети);
  - конфигурацию sniff/CSV/ограничения по времени и выбор фабрики ВМ (stub или sim).

- `loader.kt`  
  Слой работы с форматом пакета:
  - чтение заголовка `SOLP`, мета‑секции и таблицы строк;
  - интерпретация инструкций `NODE_DEF`/`CONNECT` в список `LoadedNode` и `Connection`;
  - проверка и разбор контейнеров `SOLB` (solbc) для каждого узла;
  - экспорт результата в виде структуры `LoadedProgram`.

- `runtime.kt`  
  Исполнительная часть сетевой ВМ:
  - построение сети (`buildNetwork`): создание портов, каналов, self‑каналов и проверка их согласованности;
  - создание sniffer‑каналов и coroutines для наблюдения и логирования трафика;
  - описание абстракций `NodeVm`, `NodeVmFactory`, реализация stub‑фабрики;
  - функция `runNetwork` — высокоуровневый запуск сети с параметрами логирования и ограничением времени.

- `SimNodeVmFactory.kt`  
  Адаптер между сетевой ВМ и симулятором (`solace.vm.Simulator`):
  - повторная проверка solbc‑контейнера;
  - выделение init/run‑секций в строковый байткод для симулятора;
  - запуск и координация симулятора для каждого узла в отдельной корутине.

Взаимодействие модулей:

- `Main` → `loadProgramPackage` → `buildNetwork` → `BuiltNetwork.launch(...)`.
- `buildNetwork` использует данные `LoadedProgram` и создаёт `NetworkNode` + `NodePorts`.
- `NodeVmFactory` (stub или sim) оборачивает `NetworkNode` в конкретную реализацию `NodeVm`.

## Описание реализации

### Загрузка и валидация пакета (`loader.kt`)

Ключевые типы:

- `NodeType` — перечисление типов узлов: `HARDWARE`, `SOFTWARE`.
- `PortSignature` — сигнатура портов узла: списки входных, выходных и self‑портов.
- `Endpoint` и `Connection` — описание концов соединений между узлами.
- `LoadedNode` — полностью загруженный узел (имя, тип, порты, байткод).
- `LoadedProgram` — список узлов и соединений, готовый для построения сети.

Функция `loadProgramPackage(path: Path): LoadedProgram`:

- читает все байты файла, проверяет:
  - наличие и корректность заголовка `SOLP` (магическое число, размеры, количество узлов);
  - что мета‑секция полностью умещается в файл;
- вызывает `readStringTable` для разбора таблицы строк (счётчик + длина+данные для каждой строки);
- вызывает `readInstructions`:
  - в цикле читает opcode:
    - `0x01` → `readNodeDef` — описание узла;
    - `0x02` → `readConnection` — соединение;
    - `0xFF` → конец инструкции;
  - собирает промежуточные `NodeSpec` и `Connection`.
- после разбора мета‑секции:
  - сверяет количество описанных узлов с числом в заголовке;
  - для каждого `NodeSpec` проверяет, что байткод целиком лежит внутри файла;
  - извлекает байткод и вызывает `validateSolbc`, которая:
    - проверяет magic `SOLB`;
    - читает размеры init/run‑секций и убеждается в отсутствии выхода за границы;
    - сверяет тип узла в solbc и в метаданных.
- результат — `LoadedProgram`, передаваемый в `buildNetwork`.

Функция `resolvePackagePath` поддерживает поиск файла:

- если путь существует — используется как есть;
- если путь относительный и файл не найден — путь ищется в текущем каталоге и всех родительских до корня;
- при неудаче выбрасывается `IllegalArgumentException`.

### Построение сети и запуск (`runtime.kt`)

Основные структуры:

- `NodePorts` — набор каналов узла:
  - `inputs: Map<String, ReceiveChannel<Any?>>`;
  - `outputs: Map<String, SendChannel<Any?>>`;
  - `self: Map<String, Channel<Any?>>`.
- `NetworkNode` — связка `LoadedNode` + `NodePorts`.
- `BuiltNetwork` — результат `buildNetwork`:
  - список `nodes`;
  - список `connections`;
  - список задач‑snifferов и, при необходимости, CSV‑writer.

Функция `buildNetwork(program: LoadedProgram, ...)`:

- строит словарь `nodeLookup` по именам узлов;
- для каждого узла:
  - создаёт пустые карты входных/выходных/self‑портов;
  - для каждого self‑порта создаёт один буферизованный канал и добавляет его сразу в inputs, outputs и self;
- далее проход по списку `connections`:
  - проверка, что оба конца соединения ссылаются на существующие узлы;
  - проверка наличия нужных портов в сигнатурах узлов;
  - создание пары связанных каналов через `createChannel`:
    - если sniff выключен — один общий буферизованный канал для отправителя и приёмника;
    - если включён — «проволока» (`wire`) для отправителя и «доставочный» канал (`deliver`) для приёмника, между ними — корутина‑sniffer;
  - защита от повторного подключения к уже использованным портам;
  - запись полученных каналов в карты портов соответствующих узлов.
- после обхода всех соединений:
  - для каждого узла собирается `NetworkNode`, в котором набор входов/выходов дополняется self‑портами (они видны и как вход, и как выход);
  - для отсутствующих в карте (но описанных в сигнатуре) портов создаются отдельные каналы, чтобы интерфейс был полным;
  - формируется `BuiltNetwork`, содержащий также список созданных sniffer‑задач и CSV‑writer.

Функция `createChannel` реализует sniff‑режим:

- без sniff:
  - создаётся один буферизованный канал, который возвращается как отправитель и получатель;
- со sniff:
  - создаётся пара каналов `wire` и `deliver`;
  - в отдельной корутине:
    - читаются значения из `wire`;
    - при активном лимите счётчик сообщений уменьшается, по необходимости печатается/писывается запись:
      - либо в текстовом формате `[sniff] A.out -> B.in: value`;
      - либо в CSV‑формате `A,out,B,in,value`;
    - по достижении лимита вывод отключается с диагностическим сообщением;
    - каждое значение пересылается далее в `deliver`.

Абстракции ВМ:

- `NodeVm` — единый интерфейс для любой узловой ВМ; содержит метод `launch(scope: CoroutineScope): Job`.
- `NodeVmFactory` — фабрика, создающая `NodeVm` по описанию `NetworkNode`.

Stub‑фабрика (`StubNodeVmFactory`):

- в `create(node)`:
  - вызывает `validatePorts(node)`, которая:
    - сверяет наборы портов в `NetworkNode.ports` с сигнатурой `LoadedNode.ports`;
    - убеждается, что каждый self‑порт соответствует одному и тому же каналу во входах и выходах;
  - при включённом `logPorts` выводит идентификаторы каналов для всех портов;
  - возвращает `LoggingNodeVm`, которая:
    - в отдельной корутине раз в `logIntervalMs` печатает строку вида `[hardware] NodeName alive (tick N)`/`[software] ...`.

Функция `runNetwork`:

- оборачивает запуск сети в `runBlocking`;
- вызывает `buildNetwork` (с/без sniff, CSV, лимита и файла);
- печатает краткую статистику (`N node(s), M connection(s)`);
- создаёт фабрику ВМ:
  - если `vmFactory` не передан — использует `StubNodeVmFactory`;
  - иначе использует пользовательскую (например, `SimNodeVmFactory`);
- запускает все узлы:
  - при заданном `stopAfterMs` ждёт окончания либо по таймауту, после чего:
    - отменяет все jobs и sniffer‑задачи;
    - закрывает CSV‑writer;
  - без таймаута — ждёт завершения всех узлов, затем тоже корректно завершает sniffer‑задачи и writer.

### Симуляторная фабрика (`SimNodeVmFactory.kt`)

Задача — связать сетевую ВМ с hardware ВМ.

Парсер solbc (`parseSolbc`):

- повторно проверяет заголовок `SOLB`, тип узла и размеры секций;
- вырезает init/run‑участки и интерпретирует их как UTF‑8‑строки с закодированным байткодом симулятора;
- возвращает `SolbcProgram(nodeType, initCode, runCode)`.

Фабрика `SimNodeVmFactory`:

- в `create(node)`:
  - парсит solbc для байткода узла;
  - сверяет тип узла из контейнера и из `LoadedNode`;
  - создаёт `Simulator`, загружает в него конкатенацию init+run‑кода;
  - выполняет `tryInit()` и проверяет успешность;
  - возвращает `SimNodeVm`, которая:
    - во время запуска сначала выкачивает все значения, выработанные в фазе инициализации;
    - затем в цикле:
      - сливает входящие данные из каналов портов в FIFO симулятора;
      - вызывает `simulator.tryRun()` и по статусу либо:
        - доставляет значения из FIFO обратно в сеть (`flushOutputs`);
        - либо ждёт новых входящих данных (`waitForInput` при статусе `BLOCKED`);
        - либо падает с ошибкой при статусе `ERROR`.

## Описание тестов

Тесты сетевой ВМ находятся в `vm/network/src/test/kotlin/solace/network`.

Покрываемые сценарии:

- `RuntimeTest`:
  - проверка корректной проводки self‑порта: один и тот же канал должен быть виден как вход, выход и self;
  - проверка, что `StubNodeVmFactory` отбрасывает некорректное подключение self‑порта (разные каналы на входе и выходе);
  - проверка, что корректная проводка портов принимается без исключений;
  - проверка, что sniffer‑режим при `sniffConnections = true` не ломает передачу данных: отправленное значение доходит до получателя.
- `SimNodeVmFactoryTest`:
  - сборка небольшой hardware‑сети из узлов `Pulse` и `Accumulator`;
  - генерация solbc‑контейнеров «на лету» из ассемблерных вставок (через `AsmParser`);
  - запуск сети с симуляторной фабрикой, проверка, что на выходе `Accumulator.total` формируется последовательность [1, 2, 3].
- `FibonacciNetworkTest`:
  - построение трёхузловой сети `TickSource` → `FibStepper` → `FibSink`, работающей как потоковый вычислитель Фибоначчи;
  - запуск сети с sniff‑CSV в файл, ограничение числа записей;
  - чтение последовательности чисел с выходного порта `FibSink` и сравнение с эталонной последовательностью Фибоначчи (начиная с F2);
  - параллельная проверка, что значения, записанные sniffer‑ом в CSV‑файл, совпадают с ожидаемыми.

Таким образом, тесты покрывают:

- корректность построения сети (self‑порты, wiring);
- корректность работы stub‑ и sim‑фабрик ВМ;
- интеграционную работу сетевой ВМ с реальным байткодом (через ассемблер);
- корректность режима наблюдения трафика и вывода графа сети.

## Как запустить

Из корня репозитория:

- запуск сети со stub‑ВМ:  
  `./gradlew :vm:network:run --args "build/solace/program.solpkg"`
- запуск с симулятором и sniff‑режимом, ограниченным по времени:  
  `./gradlew :vm:network:run --args "build/solace/program.solpkg --sim --sniff --duration-ms 5000"`
- выгрузка топологии в DOT без запуска ВМ:  
  `./gradlew :vm:network:run --args "build/solace/program.solpkg --dot-out build/network.dot"`

Из подкаталога `vm/network`:

- `./gradlew run --args "../build/solace/program.solpkg"`
