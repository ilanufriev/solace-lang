# Сеть Кана (network VM)

Этот модуль реализует «сетевую» виртуальную машину для языка Solace: он загружает скомпилированный пакет программы (`*.solpkg`), восстанавливает из него граф вычислительной сети (узлы и каналы между ними) и запускает узловые ВМ (stub‑, simulator‑ и Harv‑варианты, включая смешанный режим), связывая их через асинхронные FIFO‑каналы.

## Введение

Сетевая ВМ — это слой поверх отдельных узловых ВМ, отвечающий не за исполнение байткода внутри узла, а за:

- чтение бинарного пакета программы (формат описан в `FILE_FORMATS.md`);
- восстановление списка узлов (hardware/software), их портов и соединений между ними;
- построение асинхронной сети каналов (по одному FIFO‑каналу на каждое соединение и self‑порт);
- запуск для каждого узла отдельной ВМ, которая взаимодействует только через объявленные порты.

Таким образом, модуль `vm/network` позволяет:

- проверять корректность собранного пакета (валидировать заголовки и контейнеры `solbc`);
- визуализировать топологию сети (выгрузка в Graphviz DOT);
- отлаживать поведение сети с помощью «немых» заглушек, sniff‑режима и симулятора.

## ТЗ

Функциональные требования:

- Загрузка пакета программы формата `SOLP` с диска (по явно заданному пути или с поиском относительно текущего каталога вверх по дереву).
- Разбор мета‑секции: чтение таблицы строк, потока инструкций `NODE_DEF` и `CONNECT`, восстановление:
  - списка узлов с именем, типом (`HARDWARE`/`SOFTWARE`), сигнатурой портов (inputs/outputs/self);
  - списка соединений вида `from_node.from_port -> to_node.to_port`.
- Валидация пакетного формата:
  - проверка magic‑чисел (`SOLP` для пакета, `SOLB` для solbc‑контейнеров);
  - проверка размеров секций init/run и отсутствия выходов за пределы файла;
  - согласованность типа узла в метаданных и в solbc‑контейнере.
- Построение сети:
  - создание отдельных каналов FIFO для всех соединений;
  - создание self‑канала на каждый self‑порт узла и его «распараллеливание» на вход/выход;
  - строгая проверка наличия всех описанных в метаданных портов и запрет дублирующих подключений к одному и тому же входу/выходу.
- Запуск узловых ВМ:
  - поддержка stub‑фабрики (`StubNodeVmFactory`), создающей «немые» ВМ, лишь подтверждающие свою «живость» и валидирующие проводку портов;
  - поддержка симуляторной фабрики (`SimNodeVmFactory`), использующей внутренний симулятор для исполнения hardware‑узлов;
  - поддержка Harv‑фабрики (`HarvNodeVmFactory`), исполняющей software‑узлы на стековой машине (`StackMachine`) для программных сетей;
  - поддержка смешанного режима (`MixedNodeVmFactory`), направляющего hardware‑узлы в `SimNodeVmFactory`, а software‑узлы в `HarvNodeVmFactory`;
  - возможность задать длительность работы сети и остановить её по таймеру.
- Поддержка наблюдения за трафиком:
  - опция `--sniff` для вывода всех пересылаемых сообщений по каждому соединению;
  - опция `--sniff-csv`/`--sniff-csv-file` для логирования трафика в CSV (timestamp_ns,from_node,from_port,to_node,to_port,value; timestamp_ns — наносекунды с момента запуска сети) в файл или stdout;
  - ограничение числа записей на соединение через `--sniff-limit`.
- Экспорт топологии:
  - опция `--dot-out <file>` для выгрузки сети в формат DOT и выхода без запуска ВМ.

Нефункциональные требования:

- Безопасность по памяти: проверки границ при чтении бинарных структур, отказ при любых некорректных размерах/индексах.
- Диагностические сообщения при нарушениях формата, отсутствующих узлах/портах, рассинхронизации типов.
- Использование буферизованных каналов и корутин вместо блокирующих потоков, возможность ограничивать лог трафика.

Интерфейс командной строки (см. `Main.kt`):

- `solace-network <program.solpkg> [опции]`
- поддерживаемые опции:
  - `--dot-out <file>` — записать топологию в DOT‑файл и завершить;
  - `--sniff` — печатать трафик по всем соединениям;
  - `--sniff-csv` — логировать трафик в CSV (timestamp_ns,from_node,from_port,to_node,to_port,value; timestamp_ns — наносекунды с момента запуска сети; подразумевает `--sniff`);
  - `--sniff-csv-file <p>` — писать CSV в файл `<p>` (подразумевает `--sniff-csv`);
  - `--sniff-limit <n>` — максимум n сообщений на соединение;
  - `--sim` — запускать все узлы через симуляторную ВМ вместо заглушек (ожидаются только hardware‑узлы);
  - `--harv` — запускать все узлы через Harv‑ВМ (ожидаются только software‑узлы);
  - `--mixed` — смешанный режим: hardware‑узлы через симулятор, software‑узлы через Harv‑ВМ (режим по умолчанию);
  - `--duration-ms <n>` — ограничить время работы сети n миллисекундами (по умолчанию: 5000 мс при sniff‑режиме, иначе «до Ctrl+C»);
  - `--help`, `-h` — вывести справку.

Если путь к пакету не передан, по умолчанию используется `compiler/build/solace/pseudocode.solpkg` в смешанном режиме.

## Архитектура

Основные компоненты:

- `Main.kt`  
  CLI‑входная точка. Отвечает за:
  - разбор аргументов командной строки;
  - загрузку пакета (`loadProgramPackage`);
  - выбор режима работы (DOT‑выгрузка или полноценный запуск сети);
  - конфигурацию sniff/CSV/ограничения по времени и выбор фабрики ВМ (stub/sim/Harv/mixed по флагам).

- `loader.kt`  
  Слой работы с форматом пакета:
  - чтение заголовка `SOLP`, мета‑секции и таблицы строк;
  - интерпретация инструкций `NODE_DEF`/`CONNECT` в список `LoadedNode` и `Connection`;
  - проверка и разбор контейнеров `SOLB` (solbc) для каждого узла;
  - экспорт результата в виде структуры `LoadedProgram`.

- `runtime.kt`  
  Исполнительная часть сетевой ВМ:
  - построение сети (`buildNetwork`): создание портов, каналов, self‑каналов и проверка их согласованности;
  - создание sniffer‑каналов и coroutines для наблюдения и логирования трафика;
  - описание абстракций `NodeVm`, `NodeVmFactory`, реализация stub‑фабрики;
  - функция `runNetwork` — высокоуровневый запуск сети с параметрами логирования и ограничением времени.

- `SimNodeVmFactory.kt`  
  Адаптер между сетевой ВМ и симулятором (`solace.vm.Simulator`):
  - повторная проверка solbc‑контейнера;
  - выделение init/run‑секций в строковый байткод для симулятора;
  - запуск и координация симулятора для каждого узла в отдельной корутине.

- `HarvNodeVmFactory.kt`  
  Адаптер между сетевой ВМ и стековой машиной Harv (`solace.vm.StackMachine`):
  - повторная проверка solbc‑контейнера и типа узла;
  - загрузка объединённого init+run‑байткода в стековую машину и выполнение `tryInit()`;
  - интеграция FIFО машино‑узла с каналами сети по именам портов.

- `MixedNodeVmFactory.kt`  
  Простая фабрика‑маршрутизатор:
  - hardware‑узлы запускает через `SimNodeVmFactory`;
  - software‑узлы — через `HarvNodeVmFactory`.

Взаимодействие модулей:

- `Main` → `loadProgramPackage` → `buildNetwork` → `BuiltNetwork.launch(...)`.
- `buildNetwork` использует данные `LoadedProgram` и создаёт `NetworkNode` + `NodePorts`.
- Любая реализация `NodeVmFactory` (`StubNodeVmFactory`, `SimNodeVmFactory`, `HarvNodeVmFactory`, `MixedNodeVmFactory` или пользовательская) оборачивает `NetworkNode` в конкретную реализацию `NodeVm`.

## Описание реализации

### Загрузка и валидация пакета (`loader.kt`)

Ключевые типы:

- `NodeType` — перечисление типов узлов: `HARDWARE`, `SOFTWARE`.
- `PortSignature` — сигнатура портов узла: списки входных, выходных и self‑портов.
- `Endpoint` и `Connection` — описание концов соединений между узлами.
- `LoadedNode` — полностью загруженный узел (имя, тип, порты, байткод).
- `LoadedProgram` — список узлов и соединений, готовый для построения сети.

Функция `loadProgramPackage(path: Path): LoadedProgram`:

- читает все байты файла, проверяет:
  - наличие и корректность заголовка `SOLP` (магическое число, размеры, количество узлов);
  - что мета‑секция полностью умещается в файл;
- вызывает `readStringTable` для разбора таблицы строк (счётчик + длина+данные для каждой строки);
- вызывает `readInstructions`:
  - в цикле читает opcode:
    - `0x01` → `readNodeDef` — описание узла;
    - `0x02` → `readConnection` — соединение;
    - `0xFF` → конец инструкции;
  - собирает промежуточные `NodeSpec` и `Connection`.
- после разбора мета‑секции:
  - сверяет количество описанных узлов с числом в заголовке;
  - для каждого `NodeSpec` проверяет, что байткод целиком лежит внутри файла;
  - извлекает байткод и вызывает `validateSolbc`, которая:
    - проверяет magic `SOLB`;
    - читает размеры init/run‑секций и убеждается в отсутствии выхода за границы;
    - сверяет тип узла в solbc и в метаданных.
- результат — `LoadedProgram`, передаваемый в `buildNetwork`.

Функция `resolvePackagePath` поддерживает поиск файла:

- если путь существует — используется как есть;
- если путь относительный и файл не найден — путь ищется в текущем каталоге и всех родительских до корня;
- при неудаче выбрасывается `IllegalArgumentException`.

### Построение сети и запуск (`runtime.kt`)

Основные структуры:

- `NodePorts` — набор каналов узла:
  - `inputs: Map<String, ReceiveChannel<Any?>>`;
  - `outputs: Map<String, SendChannel<Any?>>`;
  - `self: Map<String, Channel<Any?>>`.
- `NetworkNode` — связка `LoadedNode` + `NodePorts`.
- `BuiltNetwork` — результат `buildNetwork`:
  - список `nodes`;
  - список `connections`;
  - список задач‑snifferов и, при необходимости, CSV‑writer.

Функция `buildNetwork(program: LoadedProgram, ...)`:

- строит словарь `nodeLookup` по именам узлов;
- для каждого узла:
  - создаёт пустые карты входных/выходных/self‑портов;
  - для каждого self‑порта создаёт один буферизованный канал и добавляет его сразу в inputs, outputs и self;
- далее проход по списку `connections`:
  - проверка, что оба конца соединения ссылаются на существующие узлы;
  - проверка наличия нужных портов в сигнатурах узлов;
  - создание пары связанных каналов через `createChannel`:
    - если sniff выключен — один общий буферизованный канал для отправителя и приёмника;
    - если включён — «проволока» (`wire`) для отправителя и «доставочный» канал (`deliver`) для приёмника, между ними — корутина‑sniffer;
  - защита от повторного подключения к уже использованным портам;
  - запись полученных каналов в карты портов соответствующих узлов.
- после обхода всех соединений:
  - для каждого узла собирается `NetworkNode`, в котором набор входов/выходов дополняется self‑портами (они видны и как вход, и как выход);
  - для отсутствующих в карте (но описанных в сигнатуре) портов создаются отдельные каналы, чтобы интерфейс был полным;
  - формируется `BuiltNetwork`, содержащий также список созданных sniffer‑задач и CSV‑writer.

Функция `createChannel` реализует sniff‑режим:

- без sniff:
  - создаётся один буферизованный канал, который возвращается как отправитель и получатель;
- со sniff:
  - создаётся пара каналов `wire` и `deliver`;
  - в отдельной корутине:
    - читаются значения из `wire`;
    - при активном лимите счётчик сообщений уменьшается, по необходимости печатается/писывается запись:
      - либо в текстовом формате `[sniff t=123456789ns] A.out -> B.in: value`;
      - либо в CSV‑формате `123456789,A,out,B,in,value` (первое поле — отметка времени в наносекундах с начала запуска сети);
    - по достижении лимита вывод отключается с диагностическим сообщением;
    - каждое значение пересылается далее в `deliver`.

Абстракции ВМ:

- `NodeVm` — единый интерфейс для любой узловой ВМ; содержит метод `launch(scope: CoroutineScope): Job`.
- `NodeVmFactory` — фабрика, создающая `NodeVm` по описанию `NetworkNode`.

Stub‑фабрика (`StubNodeVmFactory`):

- в `create(node)`:
  - вызывает `validatePorts(node)`, которая:
    - сверяет наборы портов в `NetworkNode.ports` с сигнатурой `LoadedNode.ports`;
    - убеждается, что каждый self‑порт соответствует одному и тому же каналу во входах и выходах;
  - при включённом `logPorts` выводит идентификаторы каналов для всех портов;
  - возвращает `LoggingNodeVm`, которая:
    - в отдельной корутине раз в `logIntervalMs` печатает строку вида `[hardware] NodeName alive (tick N)`/`[software] ...`.

Функция `runNetwork`:

- оборачивает запуск сети в `runBlocking`;
- вызывает `buildNetwork` (с/без sniff, CSV, лимита и файла);
- печатает краткую статистику (`N node(s), M connection(s)`);
- создаёт фабрику ВМ:
  - если `vmFactory` не передан — использует `StubNodeVmFactory`;
  - иначе использует пользовательскую (например, `SimNodeVmFactory`, `HarvNodeVmFactory`, `MixedNodeVmFactory`);
- запускает все узлы:
  - при заданном `stopAfterMs` ждёт окончания либо по таймауту, после чего:
    - отменяет все jobs и sniffer‑задачи;
    - закрывает CSV‑writer;
  - без таймаута — ждёт завершения всех узлов, затем тоже корректно завершает sniffer‑задачи и writer.

### Симуляторная фабрика (`SimNodeVmFactory.kt`)

Задача — связать сетевую ВМ с hardware ВМ.

Парсер solbc (`parseSolbc`):

- повторно проверяет заголовок `SOLB`, тип узла и размеры секций;
- вырезает init/run‑участки и интерпретирует их как UTF‑8‑строки с закодированным байткодом симулятора;
- возвращает `SolbcProgram(nodeType, initCode, runCode)`.

Фабрика `SimNodeVmFactory`:

- в `create(node)`:
  - парсит solbc для байткода узла;
  - сверяет тип узла из контейнера и из `LoadedNode`;
  - создаёт `Simulator`, загружает в него конкатенацию init+run‑кода;
  - выполняет `tryInit()` и проверяет успешность;
  - возвращает `SimNodeVm`, которая:
    - во время запуска сначала выкачивает все значения, выработанные в фазе инициализации;
    - затем в цикле:
      - сливает входящие данные из каналов портов в FIFO симулятора;
      - вызывает `simulator.tryRun()` и по статусу либо:
        - доставляет значения из FIFO обратно в сеть (`flushOutputs`);
        - либо ждёт новых входящих данных (`waitForInput` при статусе `BLOCKED`);
        - либо падает с ошибкой при статусе `ERROR`.

### Правила проводки портов

Валидация корректности сети выполняется в `StubNodeVmFactory` и опирается на следующие инварианты:

- каждый объявленный входной (`inputs`) и выходной (`outputs`) порт обязательно должен иметь канал;
- каждый `self`‑порт обязан быть одним и тем же каналом во всех трёх местах: `inputs["loop"] === outputs["loop"] === self["loop"]`;
- вход и выход не могут быть подключены более чем к одному каналу (один вход/выход — одно соединение);
- при нарушении любого из правил `StubNodeVmFactory.create(...)` бросает `IllegalArgumentException` с пояснением;
- при `logPorts = true` в лог выводятся идентификаторы каналов для всех портов, что позволяет визуально проверить, что self‑порт действительно шарит один и тот же канал.

### Как написать свою узловую ВМ

Пользовательская логика исполнения узлов описывается через пару абстракций:

- `NodeVm` — интерфейс с методом `launch(scope: CoroutineScope): Job`;
- `NodeVmFactory` — фабрика, которая по `NetworkNode` создаёт конкретную реализацию `NodeVm`.

Типичный порядок действий:

1. Реализовать `NodeVmFactory`, создающую `NodeVm` по `NetworkNode`.
2. Внутри `NodeVm.launch(scope)`:
   - читать сообщения из входных каналов: `for (msg in node.ports.inputs["in"]!!) { ... }`;
   - отправлять значения в выходные каналы: `node.ports.outputs["out"]!!.send(value)`;
   - использовать self‑порты как циклы обратной связи: отправка в `outputs["loop"]` приводит к приёму в `inputs["loop"]` того же канала.
3. Передать фабрику в сеть:
   - напрямую: `network.launch(scope, yourFactory)`;
   - или через helper `runNetwork(program, vmFactory = yourFactory, ...)`.

Минимальный пример фабрики для логирования трафика по входным портам:

```kotlin
class LoggingVmFactory : NodeVmFactory {
    override fun create(node: NetworkNode): NodeVm = object : NodeVm {
        override fun launch(scope: CoroutineScope): Job = scope.launch {
            node.ports.inputs.forEach { (name, ch) ->
                launch { for (msg in ch) println("[IN  ${node.descriptor.name}.$name] $msg") }
            }
        }
    }
}
```

## Описание тестов

Тесты сетевой ВМ находятся в `vm/network/src/test/kotlin/solace/network`.

Покрываемые сценарии:

- `RuntimeTest`:
  - проверка корректной проводки self‑порта: один и тот же канал должен быть виден как вход, выход и self;
  - проверка, что `StubNodeVmFactory` отбрасывает некорректное подключение self‑порта (разные каналы на входе и выходе);
  - проверка, что корректная проводка портов принимается без исключений;
  - проверка, что sniffer‑режим при `sniffConnections = true` не ломает передачу данных: отправленное значение доходит до получателя.
- `SimNodeVmFactoryTest`:
  - сборка небольшой hardware‑сети из узлов `Pulse` и `Accumulator`;
  - генерация solbc‑контейнеров «на лету» из ассемблерных вставок (через `AsmParser`);
  - запуск сети с симуляторной фабрикой, проверка, что на выходе `Accumulator.total` формируется последовательность [1, 2, 3].
- `FibonacciNetworkTest`:
  - построение трёхузловой hardware‑сети `TickSource` → `FibStepper` → `FibSink`, работающей как потоковый вычислитель Фибоначчи;
  - запуск сети с симуляторной фабрикой и sniff‑CSV в файл, ограничение числа записей;
  - проверка, что последовательность на выходе и в CSV‑логе совпадает с эталонной последовательностью Фибоначчи (начиная с F2).
- `HarvNodeVmFactoryTest`:
  - проверка, что Harv‑ВМ корректно реализует echo‑узел (софтверный узел пересылает значения из `in` в `out`);
  - построение софтверной сети Фибоначчи и проверка, что значения, записанные sniffer‑ом в CSV‑файл, совпадают с эталонной последовательностью.
- `DotOutTest`:
  - проверка, что флаг `--dot-out` создаёт корректный Graphviz‑файл, совпадающий с топологией сети, построенной функцией `buildNetwork`.

Таким образом, тесты покрывают:

- корректность построения сети (self‑порты, wiring);
- корректность работы stub‑, sim‑ и Harv‑фабрик ВМ;
- интеграционную работу сетевой ВМ с реальным байткодом (через ассемблер и Harv‑байткод);
- корректность режима наблюдения трафика и вывода графа сети (sniff/CSV и `--dot-out`).

## Как запустить

Из корня репозитория:

- запуск сети в смешанном режиме (по умолчанию hardware → симулятор, software → Harv):  
  `./gradlew :vm:network:run --args "build/solace/program.solpkg"`
- явный запуск в смешанном режиме:  
  `./gradlew :vm:network:run --args "build/solace/program.solpkg --mixed"`
- запуск только на симуляторе (ожидаются только hardware‑узлы):  
  `./gradlew :vm:network:run --args "build/solace/program.solpkg --sim"`
- запуск только на Harv‑ВМ (ожидаются только software‑узлы):  
  `./gradlew :vm:network:run --args "build/solace/program.solpkg --harv"`
- запуск с sniff‑режимом, CSV и ограничением времени:  
  `./gradlew :vm:network:run --args "build/solace/program.solpkg --mixed --sniff --sniff-csv --duration-ms 5000"`
- выгрузка топологии в DOT без запуска ВМ:  
  `./gradlew :vm:network:run --args "build/solace/program.solpkg --dot-out build/network.dot"`

Из подкаталога `vm/network`:

- `./gradlew run --args "../build/solace/program.solpkg"`
