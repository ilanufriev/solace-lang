# Виртуальная машина: Симулятор

## Концепция

Данная виртуальная машина реализует модель вычислений "комбинационная логика". Название "симулятор" было дано ей по аналогии с симуляторами языков описания аппаратуры Verilog, VHDL и библиотеки моделирования SystemC. Симулятор производит вычисления путем их разбиения на множество простейших элементов встречающихся в вычислительной технике. Значение выходов элементов зависит только от их входов (за редким исключением). Результаты вычисления одних элементов "перетекают" во входы последующих, как это происходит в комбинационных схемах. Таким образом, из простейших элементов составляется граф, способный производить более сложные вычисления. В коде он называется *NetlistGraph*.

## Типы элементов

Элементы, их которых строится *NetlistGraph*, выполняют базовые арифметические и логические операции. Некоторые из унарны, другие - бинарные, совсем немногие имеют количество портов большее, чем 3. Всего в языке SOLACE реализованы следующие базовые элементы:

- Adder - сумматор, складывает два числа;
- Multiplier - умножитель, умножает два числа;
- Divider - делитель, делит два числа;
- CmpLeq - сравнивает два числа (знак <=);
- CmpLess - сравнивает два числа (знак <);
- LBitShift - выполняет побитовый сдвиг влево;
- RBitShift - выполняет побитовый сдвиг вправо;
- LogicAnd - выполняет операцию логического И;
- LogicNot - выполняет операцию логического НЕ;
- LogicOr - выполняет операцию логического ИЛИ;
- Mux2 - мультиплексор с двумя входами;
- Register - хранит значение и передает его дальше по графу;
- Fifo - очередь, используемая для взаимодействия с другими виртуальными машинами.

Mux2, Register и Fifo не выполняют каких-либо операций, вместо этого они позволяют разбивать вычисления на логические части и управлять их потоком. Fifo же является особым элементом с особым поведением.

## FIFO (очереди)

FIFO (англ. First-In-First-Out, "первый вошел, первый вышел", очередь) - это элемент графа, позволяющий виртуальной машине связываться с внешним миром, то есть передавать данные другим ВМ и получать данные от них же. В отличие от всех остальных элементов, у очередей нет фиксированного количества портов. Вместо этого, порты создаются динамически по мере подключения к ним других узлов. Таким образом, у FIFO может не быть входов или выходов вовсе, и это нормальное поведение, поскольку данные забираются из очередей другой виртуальной машиной.

У FIFO могут быть как входы, так и выходы, в таком случае очередь имеет тип "self", и подключена сама к себе. Это позволяет сохранять часть состояния схемы между последовательными выполнениями инструкций блока "run {...}". С помощью self-очередей становится возможной реализация последовательных "многотактовых" схем.

## NetlistGraph

Главный класс всей виртуальной машины - это NetlistGraph, который уже упоминался ранее. Он является представлением вычислительного графа, с помощью которого и производятся все расчеты. Данный класс позволяет добавлять узлы в граф и соединять их между собой. Также у него есть метод evaluate(), который и выполняет вычисления, последовательно расчитывая значения выходов у каждого элемента графа.

Очередь выполнений (в коде evalQueue) определяет, в каком порядке будут проводится вычисления узлов. В промышленных симуляторах данная очередь формируется динамически, это ускоряет симуляцию, позволяя не тратить время на выполнение ненужных блоков. В данной виртуальной машине очередь выполнений статическая, вычисление узлов происходит в порядке их добавления в граф.

## Байт-код

Преимуществом данной виртуальной машины является минималистичность набора команд. В нем всего три команды:

- new - добавляет новый узел указанного типа к графу;
- con - соединяет два узла между собой;
- immcon - соединяет вход узла с константной величиной.

Это стало возможным благодаря тому, что весь вычислительный функционал вынесен в классы элементов, задача байткода - просто создать и соединить их в нужном порядке.

### Формат байт-кода

Парсингом, кодированием и декодированием байт-кода занимается глобальный объект AsmParser. Он содержит в себе методы, полезные при работе с ассемблером виртуальной машины. Декодированный ассемблер выглядит так:

```
.new %Fifo $in1
.new %Fifo $in2
.new %Adder $add
.new %Fifo $result

.con $in1@out $add@in1
.con $in2@out $add@in2
.con $add@out $result@in
```

Кодированные инструкции имеют формат:

```
[oпкод (Byte)][длина параметров (Short)][параметры (String)]
```

## Порядок выполнения команд и вычислений в ВМ

Виртуальная машина получает на вход байткод, который содержит как код для блока инициализации, так и код для основного блока run {...}. После этого она исполняет все инструкции, выстраивая, таким образом, вычислительный граф. После построения графа методами tryInit() и tryRun() можно запускать соответствующие блоки.

Оба блока могут вернуть один из статусов: SUCCESS, BLOCKED и ERROR. Статус SUCCESS означает, что блок успешно выполнился. Статус BLOCKED сигнализирует о том, что работа блока не может продолжаться, так как в FIFO недостаточно данных для выполнения вычислений. ERROR означает, что в ходе выполнения возникла какая-то ошибка.

## Компилятор

Компилятор для данной виртуальной машины обходит все hardware-узлы, расположенные в файле с исходным кодом. Другие узлы конструкции игнорируются. Ввиду особенностей работы виртуальной машины, принципы программирования отличаются от таковых, принятых в software-узлах и обычных императивных языках программирования, и больше напоминают функциональные языки, вроде Haskell или Lisp. Блоки init {} и run {} состоят из наборов следующих выражений:

- Запись в регистр
- Чтение из очереди
- Запись в очередь

Управление потоком производится с помощью if-else выражения, которое, в отличие от software-узлов, можно применять только при записи в регистры или очереди. Можно считать if-else выражения родственниками тернарных операторов в таких языках программирования как С/C++ или Java.

```
node AntiCounter : hardware (
    out: numbers;
    self: loop;
) {
    init {
        loop <- 10; // запись в FIFO
    }

    run {
        x = $loop - 1; // Запись в регистр

        // отправляем текущее значение в выходной FIFO
        numbers <- x;
        loop <- if (x == 0) 10 else x; // запись в FIFO с использованием if-else
    }
}
```

Регистры в hardware-узлах являются неизменяемыми, что является еще одним сходством с функциональными языками программирования. Таким образом, с помощью кода в hardware блоках создается статичная структура, в противовес обычной программе в software-узле, в которой становится возможным полноценное управление потоком и переназначение величин.

## Тестирование ВМ

Тестирование Симулятора проводилось на нескольких уровнях. Самым первым был разработано ядро симулятора - NetlistGraph, и первые тесты писались только для него. Они включали в себя проверку правильности построения и расчета графа. Также тестировался и парсер инструкций, переводивший байт-код в объекты языка kotlin и наоборот. В данном случае тестировалась правильность преобразований.

Для проверки симулятора тоже составлялись тесты. В них объекту симулятора передается байткод, сгенерированный из описания программы на ассемблере, который исполняется виртуальной машиной по вызову метода tryRun(). Данные тесты проверяли коррестность вычислений, производимых симулятором, а также механизмы блокировки при недостатке данных во входных очередях.

Наконец, последний модуль, подвергавшийся активному тестрованию - это компилятор. В этих тестах программы составлялись с помощью синтаксиса, указанного выше, после чего компилировались в байткод и запускались на виртуальной машине, с проверкой всех промежуточных результатов вычислений.

Таким образом, все основные модули были покрыты тестами, валидирующими их поведение.

