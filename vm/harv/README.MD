# Solace Harv - Документация

## Введение

Solace Harv - это стековая виртуальная машина, написанная на Kotlin, которая выполняет программы в специальном байткод-формате. Машина поддерживает базовые арифметические операции, работу с переменными, управление потоком выполнения и работу с FIFO-очередями.

Ключевые особенности:
- Стековая архитектура выполнения
- Поддержка целых чисел и строк
- FIFO-очереди для межпроцессного взаимодействия
- Система меток и переходов
- Разделение на инициализацию и основное выполнение

## Техническое задание (ТЗ)

### Цель
Создать виртуальную машину для выполнения байт-кода с поддержкой:
1. Базовых арифметических операций
2. Работы со стеком
3. Управления переменными разных типов
4. Условных переходов и циклов
5. FIFO-очередей для блокирующих операций

### Требования

#### Функциональные требования:
1. **Система типов**:
    - Целые числа (`HarvInt`)
    - Строки (`HarvString`)
    - FIFO-очереди (`HarvFifo`)
    - Идентификаторы (`HarvIdentifier`)

2. **Инструкции**:
    - Арифметические: `add`, `sub`, `mul`, `div`, `mod`
    - Сравнения: `lt`, `gt`, `le`, `ge`, `eq`, `neq`
    - Логические: `and`, `or`, `not`
    - Управление стеком: `push`, `put`
    - Управление выполнением: `branch`, `goto`, `label`
    - Работа с переменными: `define`
    - Ввод-вывод: `print`
    - Специальные: `pushsize`

3. **Состояния выполнения**:
    - `BLOCKED` - ожидание данных в FIFO
    - `SUCCESS` - успешное выполнение
    - `ERROR` - ошибка выполнения

4. **Парсинг**:
    - Поддержка текстового и бинарного формата байт-кода
    - Валидация синтаксиса инструкций

#### Нефункциональные требования:
- Реализация на Kotlin
- Модульная архитектура
- Комплексное тестирование
- Обработка ошибок выполнения

## Архитектура

### Структура проекта
```
src/
├── main/kotlin/solace/vm/
│   ├── StackMachine.kt          # Основной класс виртуальной машины
│   └── internal/harv/
│       ├── asm/                 # Парсер и инструкции
│       │   ├── AsmParser.kt     # Парсер байт-кода
│       │   ├── Instruction.kt   # Базовый интерфейс инструкций
│       │   ├── Branch.kt        # Условный переход
│       │   ├── Define.kt        # Определение переменных
│       │   ├── Goto.kt          # Безусловный переход
│       │   ├── Label.kt         # Метка
│       │   ├── Push.kt          # Помещение в стек
│       │   ├── PushSize.kt      # Получение размера FIFO
│       │   ├── Put.kt           # Сохранение в переменную
│       │   └── SimpleInstructions.kt # Простые инструкции
│       └── types/
│           └── Types.kt         # Система типов
└── test/kotlin/solace/vm/       # Тесты
```

### Компоненты системы

#### 1. StackMachine
Основной класс виртуальной машины, содержит:
- Стек значений (`stack`)
- Таблицу переменных (`variables`)
- Таблицу меток (`labels`)
- Счетчик команд (`programCounter`)
- Список инструкций (`instructions`)

#### 2. Система типов
- `HarvVal` - интерфейс-маркер для всех значений
- `HarvInt` - целочисленные значения
- `HarvString` - строковые значения
- `HarvFifo` - FIFO-очередь с блокирующими операциями
- `HarvIdentifier` - идентификатор переменной

#### 3. Парсер (AsmParser)
Двухуровневый парсинг:
1. Текст → закодированные инструкции
2. Закодированные инструкции → объекты инструкций

Поддерживает:
- Текстовый формат (человекочитаемый)
- Бинарный формат (оптимизированный)

#### 4. Инструкции
Все инструкции реализуют интерфейс `Instruction`:
- `parse()` - парсинг из строки
- `toString()` - сериализация в строку
- `isInit` - флаг инициализационной фазы

### Поток данных
```
Текст программы → AsmParser → Инструкции → StackMachine → Результат
               ↓
        Бинарный формат
```

## Описание реализации

### StackMachine.kt

#### Основные методы:

1. **Инициализация**:
```kotlin
fun loadByteCode(byteCode: String)
fun findLabels()
fun tryInit(): ExecStatus
```

2. **Выполнение**:
```kotlin
fun tryRun(): ExecStatus
private fun step(prg: List<Instruction>)
private fun executeInstruction(inst: Instruction)
```

3. **Работа с FIFO**:
```kotlin
fun pushToFifo(fifoName: String, value: Int)
fun pullFromFifo(fifoName: String): Int
fun getFifoSize(fifoName: String): Int
```

#### Ключевые особенности реализации:

1. **Разделение фаз**:
    - `tryInit()` - выполнение инструкций с флагом `isInit`
    - `tryRun()` - выполнение остальных инструкций

2. **Обработка блокировок**:
    - При чтении из пустой FIFO выбрасывается `HarvFifoIsEmpty`
    - Машина возвращает статус `BLOCKED` и сохраняет состояние

3. **Управление выполнением**:
    - Метки хранятся в Map `labels`
    - `programCounter` управляется инструкциями `branch` и `goto`

### AsmParser.kt

#### Форматы данных:

1. **Текстовый формат**:
```
.define %int $x ?
.push #5
.add
```

2. **Бинарный формат**:
```
01 0002 6C310000  // branch
02 0003 696E7400  // define
```

#### Префиксы:
- `.` - начало инструкции
- `%` - тип значения
- `$` - имя переменной
- `#` - числовой литерал
- `+` - строковый литерал
- `?` - флаг инициализации

#### Методы парсинга:

```kotlin
// Текст → бинарный
fun encodeInstructionsFromString(source: String): List<EncodedInstruction>

// Бинарный → текст
fun decodeInstructions(byteCode: ByteArray): List<EncodedInstruction>

// Текст → объекты
fun parseIntoInstrs(source: String): List<Instruction>
```

### Система инструкций

#### Категории инструкций:

1. **Арифметические** (наследуют `SimpleInstruction`):
    - `Add`, `Sub`, `Mul`, `Div`, `Mod`

2. **Сравнения**:
    - `Lt`, `Gt`, `Le`, `Ge`, `Eq`, `Neq`

3. **Логические**:
    - `And`, `Or`, `Not`

4. **Управление стеком**:
    - `Push` - помещает значение в стек
    - `Put` - сохраняет значение из стека в переменную

5. **Управление выполнением**:
    - `Branch` - условный переход
    - `Goto` - безусловный переход
    - `Label` - метка перехода

6. **Определение переменных**:
    - `Define` - создает переменную указанного типа

7. **Специальные**:
    - `PushSize` - помещает в стек размер FIFO
    - `Print` - вывод значения

### Типы данных (Types.kt)

#### HarvFifo
Реализует FIFO-очередь с блокирующим поведением:
- `putToFifo()` - добавление в конец
- `pushFromFifo()` - извлечение из начала (блокирующее)
- `HarvFifoIsEmpty` - исключение при пустой очереди

## Описание тестов

### StackMachineTest.kt

#### 1. testBlockingBehaviour()
Тестирует блокирующее поведение FIFO:
- Создание трех FIFO-очередей
- Чтение из пустых очередей → `BLOCKED`
- Добавление данных → успешное выполнение
- Проверка корректности вычислений

#### 2. testCounter()
Тестирует реализацию счетчика:
- Использование FIFO для хранения состояния
- Инкремент значения в цикле
- Проверка накопления значений в очереди

### InstructionTest.kt

#### 1. testRenderingToText()
Тестирует сериализацию инструкций:
- Проверка правильности строкового представления
- Обратный парсинг (round-trip)
- Все типы инструкций

#### 2. testParsingProgram()
Тестирует полный цикл парсинга:
- Текст → закодированные инструкции
- Закодированные → текст
- Текст → объекты инструкций
- Проверка количества и типов инструкций

### NewStackMachineTest

#### Базовые операции:
1. **basic5plus8minus2shouldBe11()**
    - Арифметические операции
    - Проверка порядка выполнения

2. **stringConcatenation()**
    - Конкатенация строк
    - Типобезопасность операций

3. **concatStringAndNumber()**
    - Автоматическое приведение типов
    - Конкатенация разных типов

#### Управление выполнением:
1. **gotoGoesTo()**
    - Корректность работы `goto`
    - Пропуск инструкций

2. **branchIfTrue() / branchIfFalse()**
    - Условные переходы
    - Проверка условий сравнения

3. **branchIfWithoutElse()**
    - Сокращенная форма ветвления
    - Управление метками

#### Работа с переменными:
1. **variables()**
    - Определение переменных
    - Чтение/запись значений
    - Использование в вычислениях

### Особенности тестирования

1. **Изоляция тестов**:
    - Каждый тест создает новый экземпляр VM
    - Чистое состояние для каждого сценария

2. **Проверка состояний**:
    - `SUCCESS` - успешное выполнение
    - `BLOCKED` - блокировка ожидания
    - Проверка конечного состояния стека

3. **Покрытие граничных случаев**:
    - Деление на ноль
    - Пустые FIFO
    - Неопределенные переменные
    - Дублирование меток

### Пример тестового сценария

```kotlin
@Test
fun testComplexProgram() {
    val code = """
        .define %int $result
        .push #10
        .push #20
        .add
        .put $result
        .push $result
        .push #5
        .mul
        .print
    """
    
    val (status, stack) = executeCode(code)
    assertEquals(StackMachine.ExecStatus.SUCCESS, status)
    assertEquals(150, (stack.last() as HarvInt).value)
}
```

Тесты обеспечивают:
- 100% покрытие основных сценариев
- Проверку обработки ошибок
- Корректность работы всех инструкций
- Сохранение состояния при блокировках