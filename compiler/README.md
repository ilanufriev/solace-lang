# Компилятор Solace (compiler)

Модуль `compiler` реализует компилятор языка Solace в формат сетевого пакета `*.solpkg`, который затем исполняется сетевой ВМ (`vm/network`). На вход подаётся текстовый файл с описанием узлов (`node ...`) и сети (`network { ... }`), на выходе получается единый бинарный контейнер с топологией и байткодом узлов.

## Введение

Компилятор решает две главные задачи:

- синтаксический и семантический анализ программы на Solace (узлы, порты, связи, аппаратный код);
- генерация бинарного пакета `SOLP` (см. `FILE_FORMATS.md`), содержащего:
  - метаданные о сети (узлы, типы, порты, соединения);
  - solbc‑контейнеры (`SOLB`) с байткодом для аппаратных узлов.

Результирующий `*.solpkg` напрямую загружается модулем `vm/network`, который:

- валидирует его структуру;
- строит сеть каналов;
- запускает узловые ВМ (stub или simulator).

Таким образом, компилятор является фронтендом/билдером сети: он проверяет корректность исходного описания и упаковывает его в формат, удобный для исполнения.

## ТЗ (техническое задание)

Функциональные требования:

- Разбор исходного файла `.solace`:
  - использование ANTLR‑грамматики (`SolaceLexer`, `SolaceParser`) для построения AST;
  - поддержка описания узлов (`node`) с типом `hardware`/`software`, портами `in`/`out`/`self`, секциями `init` и `run`;
  - поддержка секции `network { ... }` с описанием соединений `A.out -> B.in;`.
- Валидация и анализ программы:
  - синтаксическая проверка (нулевое количество syntax errors перед дальнейшей обработкой);
  - анализ топологии сети:
    - сбор списка узлов и их типов/портов;
    - сбор списка соединений;
    - проверка отсутствия:
      - ссылок на неизвестные узлы/порты;
      - дублирующихся соединений;
      - дублирующихся портов у узла;
      - неиспользованных выходных и self‑портов (если они объявлены, но никогда не используются в коде/сети).
  - диагностика ошибок через `ValidationException` и понятные сообщения.
- Генерация байткода для аппаратных узлов:
  - обход AST аппаратных узлов `HardwareVisitor`;
  - построение списка инструкций симулятора (внутренний ASM) для секций `init` и `run`;
  - кодирование инструкций в компактное строковое представление (через `AsmParser.encodeInstructions`);
  - упаковка инструкций в solbc‑контейнеры (`SOLB`) с заголовком и двумя секциями init/run.
- Формирование пакетного файла `*.solpkg`:
  - построение таблицы строк (имена узлов/портов, упомянутые в топологии и соединениях);
  - построение потока инструкций `NODE_DEF`/`CONNECT` для мета‑секции;
  - вычисление смещений и размеров solbc‑контейнеров для каждого узла;
  - запись заголовка `SOLP`, таблицы строк, инструкций и байткода в единый файл.
- Интеграция с сетевой ВМ:
  - сгенерированный пакет должен успешно загружаться `loadProgramPackage` и запускаться через `buildNetwork` + `SimNodeVmFactory`.

Нефункциональные требования:

- Строгая проверка формата:
  - ограничения на количество строк и длину каждой строки в таблице;
  - проверки на переполнения u16/u32 при записи длины/смещений;
  - гарантированное соответствие длины потока инструкций заранее рассчитанному значению.
- Удобство диагностики:
  - сообщения об ошибках с контекстом (какой узел/порт/соединение вызвали проблему);
  - разделение ошибок синтаксиса (ANTLR), семантики (`ValidationException`) и ошибок аппаратного компилятора (`HardwareVisitorException`).
- Совместимость с рантаймом:
  - формат `SOLP/SOLB`, генерируемый компилятором, должен полностью соответствовать ожиданиям загрузчика в `vm/network`.

CLI‑интерфейс (см. `App.kt`):

- `solace-compiler <input.solace> [--out <outputDir>] [--print-ast] [--help]`
- опции:
  - `--out, -o <dir>` — каталог для вывода (`build/solace` по умолчанию);
  - `--print-ast` — печать дерева разбора (AST) в текстовом виде перед валидацией и компиляцией;
  - `--help`, `-h` — вывод краткой справки.
- если входной файл не указан, по умолчанию используется `../pseudocode.solace` (с диагностическим сообщением).

## Архитектура

Основные компоненты:

- `App.kt`  
  Входная точка CLI:
  - разбирает аргументы командной строки (`parseArgs`);
  - вызывает `compileFile`, которая:
    - находит исходный файл (`resolveInputPath`);
    - парсит его в AST (`parseTopology`);
    - опционально печатает AST (`prettyTree`);
    - при отсутствии синтаксических ошибок:
      - вызывает `buildHardwareBytecode` для генерации байткода;
      - вызывает `analyzeProgram` для анализа топологии;
      - вызывает `writeProgramPackage` для записи `*.solpkg`.

- `hardwareCompilation.kt`  
  Слой компиляции аппаратных узлов:
  - обходит AST с помощью `HardwareVisitor`, получая список описаний узлов;
  - для каждого аппаратного узла строит solbc‑контейнер:
    - кодирует init/run‑инструкции через `AsmParser.encodeInstructions`;
    - заворачивает их в `buildSolbcContainer(NodeType.HARDWARE, init, run)`.

- `packaging.kt`  
  Генератор бинарного пакета `*.solpkg`:
  - строит таблицу строк по топологии (`buildStringTable`);
  - проверяет ограничения по количеству строк и длинам (`validateStringTable`);
  - считает длину потока инструкций (`computeInstructionLength`);
  - раздаёт непрерывное адресное пространство под solbc‑контейнеры (`buildBytecodeBlocks`);
  - формирует поток инструкций `NODE_DEF`/`CONNECT` (`buildInstructionStream`);
  - собирает заголовок `SOLP` (`buildPackageHeader`) и окончательный файл (`writeProgramPackage`).

- `TreePrinter.kt`  
  Утилита для отладки парсера:
  - функция `prettyTree(tree, parser)` строит текстовое дерево AST с ASCII‑ветвлением;
  - используется в тестах и опции `--print-ast`.

Дополнительные компоненты (в других файлах/пакетах, но логически относящиеся к компилятору):

- `NetworkVisitor` — реализует анализатор сети (`analyzeProgram`): обходит AST (`SolaceParser.ProgramContext`), строит `NetworkTopology` (узлы, порты, соединения), проверяет корректность узлов/портов/соединений и выбрасывает `ValidationException` при нарушениях (дубликаты, неизвестные узлы/порты, неиспользованные порты, лишние `network`‑секции);
- `HardwareVisitor` — превращает синтаксические конструкции аппаратного узла в низкоуровневый набор инструкций симулятора.

Взаимодействие модулей:

- `App.main` → `parseTopology` → `analyzeProgram` → `buildHardwareBytecode` → `writeProgramPackage`.
- Сгенерированный `*.solpkg` затем используется `vm/network`:
  - `loadProgramPackage` → `buildNetwork` → запуск узлов.

## Описание реализации

### Парсер и CLI (`App.kt`)

Ключевые элементы:

- `parseArgs`:
  - проход по аргументам с поддержкой:
    - `--out`/`-o` для каталога вывода;
    - `--print-ast` для включения режима печати дерева;
    - `--help`/`-h` для вывода справки;
  - при отсутствии входного файла подставляет `../pseudocode.solace`, чтобы можно было быстро попробовать компилятор.
- `parseTopology(path)`:
  - создаёт `CharStreams` из файла;
  - пропускает через `SolaceLexer` и `SolaceParser`;
  - возвращает пару (`parser`, `ProgramContext`).
- `compileFile`:
  - вызывает `parseTopology` и, при включённом `printAst`, печатает `prettyTree(tree, parser)`;
  - при наличии синтаксических ошибок прекращает дальнейшую работу, печатает их количество;
  - в блоке `try`:
    - `buildHardwareBytecode(tree)` — генерация байткода для аппаратных узлов;
    - `analyzeProgram(tree)` — построение топологии и проверка корректности сети;
    - `packageNameFor(input)` — формирование имени выходного файла (`*.solpkg`);
    - `writeProgramPackage(...)` — запись пакета на диск;
    - печать краткой статистики: сколько узлов собрано и путь к пакету;
  - ловит и диагностирует:
    - `ValidationException` — ошибки семантики/топологии;
    - `HardwareVisitorException` — ошибки аппаратной части.
- `resolveInputPath`:
  - сначала пытается использовать путь как есть;
  - если не найден и путь относительный — ищет на уровень выше (удобно при запуске из подкаталогов);
  - при неудаче выбрасывает `IllegalArgumentException`.

### Генерация аппаратного байткода (`hardwareCompilation.kt`)

Ключевые элементы:

- `buildHardwareBytecode(program: ProgramContext)`:
  - создаёт `HardwareVisitor` и прогоняет его по всему AST;
  - результат приводится к списку `HardwareVisitor.Node`;
  - делегирует работу перегрузке `buildHardwareBytecode(nodes)`.
- `buildHardwareBytecode(nodes: List<HardwareVisitor.Node>)`:
  - для каждого аппаратного узла:
    - извлекает имя, init‑ и run‑код (в терминах списка инструкций симулятора);
    - проверяет уникальность имён узлов (запрещает дубликаты);
    - вызывает `buildSolbcContainer(NodeType.HARDWARE, initBytes, runBytes)`, где:
      - `encodeInstructions` кодирует список инструкций в строку (через `AsmParser.encodeInstructions`) и затем в UTF‑8‑байты;
  - возвращает карту `nodeName -> solbc‑байткод`.
- `encodeInstructions`:
  - пустой список даёт пустой массив байт (узел с пустым init/run);
  - непустой — кодируется и конкатенируется в единую строку байткода.

### Формирование пакета `*.solpkg` (`packaging.kt`)

Ключевые структуры:

- `BytecodeBlock` — описывает байткод одного узла в пакете:
  - имя узла;
  - смещение внутри файла;
  - массив байт и его размер.

Ключевые функции:

- `writeProgramPackage(topology, bytecodeByNode, outputDir, packageName)`:
  - строит глобальный список строк `strings` через `buildStringTable(topology)`:
    - имена узлов;
    - имена портов (inputs/outputs/self);
    - имена узлов и портов, встречающиеся в соединениях;
  - проверяет таблицу строк (`validateStringTable`):
    - число строк ≤ 65535;
    - длина каждой строки в UTF‑8 байтах ≤ 65535;
  - формирует байтовое представление таблицы (`buildStringTableBytes`):
    - `u32 count` + последовательность записей `u16 length + bytes`;
  - оценивает длину потока инструкций (`computeInstructionLength(topology)`), учитывая:
    - для каждого узла:
      - opcode, идентификатор имени, тип, количество и идентификаторы портов, смещения и размеры байткода, формат;
    - для каждого соединения:
      - opcode и 4 идентификатора строк (узлы/порты);
    - завершающий байт `END`;
  - вычисляет базовое смещение для секции байткода:
    - `baseOffset = PACKAGE_HEADER_SIZE + metaSize` (где `metaSize = stringTableBytes.size + instructionsLength`);
  - создаёт список `BytecodeBlock` через `buildBytecodeBlocks`:
    - для каждого узла:
      - находит байткод по имени узла в `bytecodeByNode`;
      - при отсутствии — для `HARDWARE` бросает исключение, для `SOFTWARE` собирает пустой solbc‑контейнер (`buildEmptySolbc`);
      - назначает непрерывные смещения (offset) с учётом длины предыдущих блоков;
  - формирует поток инструкций `NODE_DEF`/`CONNECT` (`buildInstructionStream`):
    - для каждого узла:
      - записывает:
        - opcode `0x01`;
        - u16‑идентификатор имени;
        - тип узла (0 — hardware, 1 — software);
        - количество и идентификаторы входных/выходных/self‑портов;
        - u32‑смещения и размеры байткода;
        - формат байткода (`1` = solbc);
      - контролирует, что количество портов ≤ 255 (ограничение u8);
    - для каждого соединения:
      - opcode `0x02` + 4 u16‑идентификатора (from_node, from_port, to_node, to_port);
    - завершает поток байтом `0xFF` (END);
  - проверяет, что фактическая длина инструкций совпадает с рассчитанной;
  - создаёт каталог вывода, открывает файл и по порядку записывает:
    - заголовок `SOLP` (`buildPackageHeader`);
    - таблицу строк;
    - поток инструкций;
    - байткод всех узлов (по списку `BytecodeBlock`).
- Вспомогательные writer‑ы:
  - `writeU8`, `writeU16`, `writeU32` — записывают числа в формате little‑endian, контролируя переполнения для u16;
  - `buildSolbcContainer` — общий конструктор solbc‑контейнера для hardware/software узлов:
    - записывает заголовок `SOLB` (magic, версия, тип узла, isa_version, flags, размеры init/run);
    - приклеивает байты секций init и run.

Таким образом, упаковщик строго следует формату, ожидаемому загрузчиком в `vm/network/loader.kt`, и гарантирует согласованность метаданных и секций байткода.

## Описание тестов

Тесты модуля компилятора расположены в `compiler/src/test/kotlin/solace/compiler`.

Покрываемые сценарии:

- `ParserConstructsTest`:
  - проверяет, что парсер корректно разбирает:
    - выражения и управляющие конструкции (`if`, логические операции, сдвиги, унарные операции);
    - аппаратные конструкции: чтение/запись FIFO, условные выражения в hardware‑коде;
    - объявление сети (`network { ... }`) и соединений между узлами;
    - минимальный узел без портов;
  - использует `prettyTree` для визуальной проверки AST и функции `hasNode` для поиска нужных контекстов ANTLR.
- `NetworkAnalysisTest`:
  - проверяет работу семантического анализатора сети (`analyzeProgram`):
    - успешный сбор узлов и соединений в корректной программе;
    - ошибки при:
      - ссылке на неизвестный узел;
      - дублирующемся соединении;
      - неиспользованных выходных/self‑портах;
      - дублирующихся портах в объявлении узла;
    - особый случай: self‑порт, используемый в коде (чтение/запись), не должен считаться неиспользованным.
- `HardwareVisitorTest`:
  - проверяет, что `HardwareVisitor`:
    - корректно собирает информацию о аппаратных узлах (имена, выходы, self‑порты, регистры);
    - генерирует байткод, который:
      - правильно инициализирует self‑порты;
      - реализует простые счётчики/анти‑счётчики;
      - реализует арифметические операции (например, удвоение входного значения);
    - применяет сгенерированный байткод к реальному `Simulator` и сверяет:
      - статусы исполнения (`SUCCESS`/`BLOCKED`);
      - содержимое FIFO после последовательных запусков.
- `PackagingIntegrationTest`:
  - интеграционный тест компилятора и сетевой ВМ:
    - создаёт небольшую аппаратную сеть `Pulse` → `Accumulator` на уровне исходного языка Solace;
    - прогоняет её через полный пайплайн:
      - парсинг → анализ сети → генерация байткода → упаковка в `*.solpkg`;
    - затем загружает пакет через `loadProgramPackage` и запускает сеть через `buildNetwork` + `SimNodeVmFactory`;
    - проверяет, что на выходе `Accumulator.total` формируется последовательность [1, 2, 3].

В сумме тесты покрывают:

- корректность парсинга конструкций языка;
- семантический анализ сети и диагностику ошибок;
- корректность генерации аппаратного байткода и его исполнения симулятором;
- целостность формата `*.solpkg` и его совместимость с сетевой ВМ.
